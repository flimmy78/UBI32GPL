/*=======================================================================
  
       Copyright(c) 2009, Works Systems, Inc. All rights reserved.
  
       This software is supplied under the terms of a license agreement 
       with Works Systems, Inc, and may not be copied nor disclosed except 
       in accordance with the terms of that agreement.
  
  =======================================================================*/
/*!
 * \file task.c
 * \brief File Transfer & Download/Upload Diagnostics
 * This is the file transfer implementation of TR069. I also mix the Download/Upload Diagnostics(TR143)
 * into the file transfer.
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "task.h"
#include "session.h"
#include "tr.h"
#include "event.h"
#include "request.h"
#include "log.h"
#include "sched.h"
#include "xml.h"
#include "buffer.h"
#include "http.h"
#include "tr_lib.h"
#include "network.h"
#include "tr_strings.h"
#include "echo.h"
#include "cli.h"
#include "war_string.h"
#include "war_socket.h"
#include "war_time.h"
#include "war_errorcode.h"
#include "war_type.h"

#ifdef TR196
#include "pm.h"
#endif

#define TASK_FILE "tasks"
#define TASK_QUEUE_LEN_LIMIT 6

enum {
	TASK_TYPE_UPLOAD = 0,
	TASK_TYPE_DOWNLOAD,
	TASK_TYPE_DOWNLOAD_DIAGNOSTICS,
	TASK_TYPE_UPLOAD_DIAGNOSTICS
};

enum {
	TASK_STATE_NOT_STARTED = 1,
	TASK_STATE_IN_PROCESS,
	TASK_STATE_COMPLETED
};

enum {
	TASK_NEXT_HTTP_HEADER,
	TASK_NEXT_HTTP_BODY,
	TASK_NEXT_COMPLETE
};

enum {
	TASK_INITIATED_ACS = 0,
	TASK_INITIATED_AUTONOMOUS
};


struct task_config {
	const char type[64];
	const char path[128];
	struct task_config *next;
};


struct task {
	unsigned int type:2; // TASK_TYPE_DOWNLOAD, TASK_TYPE_UPLOAD, TASK_TYPE_DOWNLOAD_DIAGNOSTICS or TASK_TYPE_UPLOAD_DIAGNOSTICS
	unsigned int state:3;
	unsigned int initiated:1; //TASK_INITIATED_ACS, TASK_INITIATED_AUTONOMOUS
	unsigned int:0;
	char url[257];
	char announce_url[257];
	union {
		struct {
			char cmd_key[33];
			char username[257];
			char password[257];
			char target_file_name[257]; //For UPLOAD this should be generated by CPE itself
			int file_size;  //Just used for Download
			time_t delay; //MUST be current + DelaySeconds indeed
			//Do not support SuccessURl and FailureURL

			char file_type[64];
		}file;
	#ifdef TR143
		struct {
			char inter[32];
			struct timeval rom, bom, eom;
			struct timeval request_time, response_time;
			unsigned int test_file_length;
			unsigned int total_bytes_sent;
			unsigned int already_sent;
			unsigned int test_bytes_received;
			unsigned int total_bytes_received;
			int dscp;
			int ep;
			const char *eod; //Error message on destroy
		}diag;
	#endif
	}du;

	struct sched *sc;
	struct task *next;
};

struct task_item {
	struct task *t;
	struct http http;
	struct connection conn;
	int fault_code; //9001, 9002, 9010, 9011, 9012, 9014, 9015, 9016, 9017, 9018, 9019. success should be zero
	char start_time[32];
	char complete_time[32];
	unsigned int challenged:1;
	unsigned int next_step:7;
	int offset;
	struct buffer outbuf;
	FILE *upfile; //For upload
};

static int trust_target_file_name = 0;
static struct task *task_list = NULL;

static struct task_config *uploads = NULL;
static struct task_config *downloads = NULL;


#ifdef TR143
static void xd_error(const char *path, const char *error)
{
	node_t node;
	if(lib_start_session() > 0) {
		if(lib_resolve_node(DD_STATE, &node) == 0)
			lib_set_value(node, error);
		lib_end_session();
	}
}

#define dd_error(e) xd_error(DD_STATE, e)
#define ud_error(e) xd_error(UD_STATE, e)
#endif

static struct task_config *get_file_type_by_name(int task_type, char *file_type)
{
	struct task_config *tc;

	if(task_type == TASK_TYPE_DOWNLOAD)
		tc = downloads;
	else
		tc = uploads;

	for(; tc; tc = tc->next) {
		if(war_strcasecmp(tc->type, file_type) == 0)
			return tc;
	}

	return NULL;
}


int add_task_config(const char *name, const char *value)
{
	char *type;
	char *path;
	char c[256];
	struct task_config *tc = NULL;
	struct task_config **tcs;

	if(war_strcasecmp(name, "Upload") == 0) {
		tcs = &uploads;
	} else if(war_strcasecmp(name, "Download") == 0) {
		tcs = &downloads;
	} else if(war_strcasecmp(name, "TrustTargetFileName") == 0) {
		trust_target_file_name = string2boolean(value);
		return 0;
	} else {
		return 0;
	}

	war_snprintf(c, sizeof(c), "%s", value);
	type = c;
	path = strchr(type, ':');
	if(path) {
		*path = '\0';
		path++;
	} else {
		path = "";
	}

	type = skip_blanks(type);
	trim_blanks(type);
	path = skip_blanks(path);
	trim_blanks(path);

	if(path[0] == '\0' || type[0] == '\0') {
		tr_log(LOG_WARNING, "Invalid upload config!");
	} else {
		tc = malloc(sizeof(*tc));
		if(tc == NULL) {
			tr_log(LOG_ERROR, "Out of memory!");
			return -1;
		}

		war_snprintf((char *)(tc->type), sizeof(tc->type), "%s", type);
		war_snprintf((char *)(tc->path), sizeof(tc->path), "%s", path);

		tc->next = *tcs;
		*tcs = tc;
	}

	return 0;
}

static int write_task2disk()
{
	FILE *fp;
	tr_backup(TASK_FILE);
	fp = tr_fopen(TASK_FILE, "wb");
	if(fp) {
		struct task *r;
		for(r = task_list; r; r = r->next) {
			if(r->type == TASK_TYPE_DOWNLOAD || r->type == TASK_TYPE_UPLOAD)
				fwrite(r, 1, sizeof(struct task), fp);
		}
		fflush(fp);
		fclose(fp);
		tr_remove_backup(TASK_FILE);
		return 0;
	} else {
		return -1;
	}
}

static int del_task(struct task *t)
{
	struct task *prev, *cur;

	for(prev = NULL, cur = task_list; cur; ) {
		if(cur == t) {
			if(prev)
				prev->next = cur->next;
			else
				task_list = cur->next;

			if(cur->type == TASK_TYPE_DOWNLOAD || cur->type == TASK_TYPE_UPLOAD) {
				write_task2disk();
			}
			free(cur);
			break;
		} else {
			prev = cur;
			cur = cur->next;
		}
	}

	return 0;
}

static void task_timeout(struct sched *sc)
{
	struct task_item *ti;

	ti = (struct task_item *)(sc->pdata);
	sc->need_destroy = 1;
	switch(ti->t->type) {
		case TASK_TYPE_DOWNLOAD:
			ti->fault_code = 9010;
			break;
		case TASK_TYPE_UPLOAD:
			ti->fault_code = 9011;
			break;
	}
}

static int task_http_header(struct task_item *ti)
{
	const char *keep_alive;

	if(ti->challenged)
		http_update_authorization(&(ti->http), ti->t->du.file.username, ti->t->du.file.password);
#ifdef TR143
	if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS || ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS)
		keep_alive = "close";
	else
#endif
		keep_alive = "keep-alive";
	switch(ti->t->type) {
		case TASK_TYPE_DOWNLOAD:
	#ifdef TR143
		case TASK_TYPE_DOWNLOAD_DIAGNOSTICS:
	#endif
			push_buffer(&(ti->outbuf),
				"GET %s HTTP/1.1\r\n"
				"Host: %s:%s\r\n"
				"User-Agent: " TR069_CLIENT_VERSION "\r\n"
				"Cache-Control: no-cache\r\n"
				"Connection: %s\r\n"
				"Content-Length: 0\r\n"
				"%s"
				"\r\n", ti->conn.path, ti->conn.host, ti->conn.port, keep_alive, ti->http.authorization);
			break;
		default:
			push_buffer(&(ti->outbuf),
				"PUT %s HTTP/1.1\r\n"
				"Host: %s:%s\r\n"
				"User-Agent: " TR069_CLIENT_VERSION "\r\n"
				"Connection: %s\r\n"
				"Content-Type: text/plain\r\n"
				"Transfer-Encoding: chunked\r\n"
				"%s"
				"\r\n", ti->conn.path, ti->conn.host, ti->conn.port, keep_alive, ti->http.authorization);
			break;
	}
#ifdef TR143
	if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS || ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS)
		war_gettimeofday(&(ti->t->du.diag.rom), NULL);
#endif

	return METHOD_COMPLETE;
}

static void on_task_writable(struct sched *sc)
{
	struct task_item *ti;

	ti = (struct task_item *)(sc->pdata);
	for(;;) {
		sc->timeout = current_time() + 60;
		if(ti->offset < ti->outbuf.data_len) {
			int len;

			len = tr_conn_send(&(ti->conn), ti->outbuf.data + ti->offset, ti->outbuf.data_len - ti->offset);
			if(len > 0) {
				ti->offset += len;
			} else {
				sc->need_destroy = 1;
				if(ti->t->type == TASK_TYPE_DOWNLOAD || ti->t->type == TASK_TYPE_UPLOAD) {
					tr_log(LOG_ERROR, "Send to file server failed!");
					ti->fault_code = ti->t->type == TASK_TYPE_DOWNLOAD ? 9010 : 9011;
				}
			}
			return;
		}

		ti->offset = 0;
		reset_buffer(&(ti->outbuf));

		if(ti->next_step == TASK_NEXT_HTTP_HEADER) {
		#ifdef TR143
			if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS || ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS) {
				war_gettimeofday(&(ti->t->du.diag.response_time), NULL);
				ti->t->du.diag.eod = "Error_NoResponse";
			}
		#endif
			task_http_header(ti);
			ti->next_step = TASK_NEXT_HTTP_BODY;
		} else if(ti->next_step == TASK_NEXT_HTTP_BODY) {
			switch(ti->t->type) {
				case TASK_TYPE_DOWNLOAD:
					destroy_buffer(&(ti->outbuf));
					ti->http.body_size = 0;
			#ifdef TR143
				case TASK_TYPE_DOWNLOAD_DIAGNOSTICS:
			
					if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS) {
						ti->http.body_type = HTTP_BODY_NONE;
						ti->t->du.diag.eod = "Error_NoResponse";
					} else 
			#endif
					{
						if(ti->t->du.file.file_size > 0)
							ti->http.body_limit = ti->t->du.file.file_size;
						else
							ti->http.body_limit = lib_disk_free_space(ti->t->du.file.file_type);
						ti->http.body_type = HTTP_BODY_FILE;
						ti->http.body = tr_fopen(ti->t->du.file.target_file_name, "wb");
						if(ti->http.body == NULL) {
							ti->fault_code = 9002;
							war_snprintf(ti->complete_time, sizeof(ti->complete_time), "%s", lib_current_time());
							sc->need_destroy = 1;
						}
					}
					ti->http.block_len = 0;
					ti->http.state = HTTP_STATE_RECV_HEADER;
					sc->type = SCHED_WAITING_READABLE;
					sc->timeout = current_time() + 60;
					return;
				default: //UPLOAD or UPLOAD_DIAGNOSTICS
					if(ti->t->type == TASK_TYPE_UPLOAD && ti->upfile == NULL) {
						ti->upfile = tr_fopen(ti->t->du.file.target_file_name, "rb"); //lib_file_path MUST return an absolute file path
						if(ti->upfile == NULL) {
							tr_log(LOG_WARNING, "Open file failed in upload!");
							ti->fault_code = 9002;
							war_snprintf(ti->complete_time, sizeof(ti->complete_time), "%s", lib_current_time());
							sc->need_destroy = 1;
							return;
						}
						ti->http.body_type = HTTP_BODY_NONE;
					}

					if(ti->upfile || ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS) { 
						char buf[512] = "";
						int res = -1;
						if(ti->t->type == TASK_TYPE_UPLOAD) {
							res = fread(buf, 1, sizeof(buf) - 1, ti->upfile);
						}
					#ifdef TR143
						 else if(ti->t->du.diag.test_file_length > ti->t->du.diag.already_sent){
							/*int i;*/
							if(ti->t->du.diag.already_sent == 0) {
								war_gettimeofday(&(ti->t->du.diag.bom), NULL);
								ti->t->du.diag.total_bytes_sent = lib_get_interface_traffic(ti->t->du.diag.inter, TRAFFIC_OUTBOUND);
							}
							/*for(res = 0; res < sizeof(buf) - 31;) {
								i = war_snprintf(buf + res, sizeof(buf) - res, "Upload Diagnostics DummyContent");
								if(i == 31) {
									res += i;
								} else {
									break;
								}

								if(res > ti->t->test_file_length - ti->t->already_sent) {
									res = ti->t->test_file_length - ti->t->already_sent;
									buf[res] = '\0';
									break;
								}
							}*/
							memset(buf, 'A', sizeof(buf) - 1);
							if(ti->t->du.diag.test_file_length - ti->t->du.diag.already_sent >= sizeof(buf) - 1)
								res = sizeof(buf) - 1;
							else
								res = ti->t->du.diag.test_file_length - ti->t->du.diag.already_sent;
							buf[res] = '\0';
							ti->t->du.diag.already_sent += res;
						} else {
							res = 0;
						}	
					#endif	
						if(res >= 0) {
							buf[res] = '\0';
							push_buffer(&(ti->outbuf), "%x\r\n%s\r\n", res, buf);
							if(res == 0)
								ti->next_step = TASK_NEXT_COMPLETE;
							continue;
						} else {
							ti->fault_code = 9002;
							war_snprintf(ti->complete_time, sizeof(ti->complete_time), "%s", lib_current_time());
							sc->need_destroy = 1;
							return;
						}
					} else {
						ti->fault_code = 9002;
						war_snprintf(ti->complete_time, sizeof(ti->complete_time), "%s", lib_current_time());
						sc->need_destroy = 1;
						return;
					}
				break;
			}
		} else { //TASK_NEXT_COMPLETE
			sc->type = SCHED_WAITING_READABLE; //Waiting to receive the response
			sc->timeout = current_time() + 60;
			destroy_buffer(&(ti->outbuf));
			ti->offset = 0;
			ti->http.sl_flag = 0;
			ti->http.header_count = 0;
			ti->http.block_len = 0;
			ti->http.body_type = HTTP_BODY_NONE;
			ti->http.state = HTTP_STATE_RECV_HEADER;
		#ifdef TR143
			if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS || ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS) {
				ti->t->du.diag.eod = "Error_NoResponse";
			}
		#endif

			return;
		}
	} //for(;;)
}
#ifdef TR143
static void dd_waiting_peer_close(struct sched *sc)
{
	struct task_item *ti;
	char buf[2];

	ti = (struct task_item *)(sc->pdata);
	if(tr_conn_recv(&(ti->conn), buf, sizeof(buf)) == 0) {//Peer close the connection
		ti->t->du.diag.eod = "Completed";
		war_gettimeofday(&(ti->t->du.diag.eom), NULL);
		ti->t->du.diag.total_bytes_received = lib_get_interface_traffic(ti->t->du.diag.inter, TRAFFIC_INBOUND) - ti->t->du.diag.total_bytes_received;
	} else { //More data than expected or timeout
		ti->t->du.diag.eod = "Error_TransferFailed";
	}

	sc->need_destroy = 1;
}
#endif


static void on_task_readable(struct sched *sc)
{
	struct task_item *ti;
	int fault_code = 0;
	int res;
	int res_code = 200;
	ti = (struct task_item *)(sc->pdata);
#ifdef TR143
	if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS || ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS) {
		if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS && ti->t->du.diag.bom.tv_sec == 0 && ti->t->du.diag.bom.tv_usec == 0) {
			war_gettimeofday(&(ti->t->du.diag.bom), NULL);
			ti->t->du.diag.total_bytes_received = lib_get_interface_traffic(ti->t->du.diag.inter, TRAFFIC_INBOUND);
		}
		ti->t->du.diag.eod = "Error_NoResponse";
	}
#endif
	res = http_recv(&(ti->http), &(ti->conn));
	if(res == HTTP_COMPLETE && ti->http.msg_type == HTTP_RESPONSE) {
		res_code = atoi(ti->http.start_line.response.code);
		switch(res_code) {
			case 200:
				if(ti->t->type == TASK_TYPE_DOWNLOAD && 
						ti->t->du.file.file_size > 0 && 
						ti->http.body_size != ti->t->du.file.file_size) {
					tr_log(LOG_ERROR, "Download expected %d bytes, but received %d bytes", ti->t->du.file.file_size, ti->http.body_size);
					fault_code = 9018;
				} 
			#ifdef TR143
				else if(ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS) {
					ti->t->du.diag.eod = "Completed";
					war_gettimeofday(&(ti->t->du.diag.eom), NULL);
					ti->t->du.diag.total_bytes_sent = lib_get_interface_traffic(ti->t->du.diag.inter, TRAFFIC_OUTBOUND) - ti->t->du.diag.total_bytes_sent;
				}
			#endif
				break;
			case 201:
			case 204:
			#ifdef TR143
				if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS) {
					//ti->t->eod = "Completed";
				} else if(ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS) {
					ti->t->du.diag.eod = "Completed";
					war_gettimeofday(&(ti->t->du.diag.eom), NULL);
					ti->t->du.diag.total_bytes_sent = lib_get_interface_traffic(ti->t->du.diag.inter, TRAFFIC_OUTBOUND) - ti->t->du.diag.total_bytes_sent;
				} else
			#endif
				{
					fault_code = 0;
				}
				res_code = 200;
				break;
			case 301:
			case 302:
			case 307:
				tr_log(LOG_WARNING, "Filetrtansfer redirected, regards as failure!");
				if(ti->t->type == TASK_TYPE_DOWNLOAD) {
					fault_code = 9010;
				} else if(ti->t->type == TASK_TYPE_UPLOAD) {
					fault_code = 9011;
				}
				break;
			case 401:
			case 407:
			#ifdef TR143
				if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS || ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS) {
				} else
			#endif
				if(ti->challenged == 0 && http_auth(&(ti->http), ti->t->du.file.username, ti->t->du.file.password, ti->t->type == TASK_TYPE_DOWNLOAD ? "GET" : "PUT", ti->conn.path) == 0) {
					char *header;

					tr_log(LOG_WARNING, "Filetransfer need authenticate!");
					header = http_get_header(&(ti->http), "Connection:");
					if(header && war_strncasecmp(header, "close", 5) == 0) {
						tr_disconn(&(ti->conn));
						memset(&(ti->conn), 0, sizeof(ti->conn));
						if(tr_conn(&(ti->conn), ti->t->url) != 0) {
							if(ti->t->type == TASK_TYPE_DOWNLOAD)
								fault_code = 9015;
							else
								fault_code = 9011;
							break;
						} else {
							sc->fd = ti->conn.fd;
						}
					}

					//caculate authorization
					if(ti->upfile) {
						fclose(ti->upfile);
						ti->upfile = NULL;
					}

					ti->http.inbuf[0] = '\0';
					ti->http.inlen = 0;
					del_http_headers(&(ti->http));
					if(ti->http.body) {
						fflush((FILE *)(ti->http.body));
						fclose((FILE *)(ti->http.body));
						ti->http.body = NULL;
					}

					sc->type = SCHED_WAITING_WRITABLE;
					sc->timeout = current_time() + 60;
					ti->challenged = 1;
					ti->next_step = TASK_NEXT_HTTP_HEADER;
					del_http_headers(&(ti->http));
					return;
				} else {
					fault_code = 9012;
				}
				break;
			case 404:
				if(ti->t->type == TASK_TYPE_DOWNLOAD) {
					fault_code = 9016;
				} else if(ti->t->type == TASK_TYPE_UPLOAD) {
					fault_code = 9012;
				}
				break;
			default:
				tr_log(LOG_WARNING, "Filetransfer receive response code: %s", ti->http.start_line.response.code);
				if(ti->t->type == TASK_TYPE_DOWNLOAD) {
					fault_code = 9010;
				} else if(ti->t->type == TASK_TYPE_UPLOAD) {
					fault_code = 9011;
				}
				break;
		}
	} else if(res == HTTP_ERROR) {
		if(ti->t->type == TASK_TYPE_DOWNLOAD) {
			fault_code = 9017;
		} else if(ti->t->type == TASK_TYPE_UPLOAD) {
			fault_code = 9011;
		}
	} else if(res == HTTP_BODY_TOO_LARGE) {
		tr_log(LOG_ERROR, "Download expected %d bytes, but received %d bytes", ti->t->du.file.file_size, ti->http.body_size);
		fault_code = 9018;
	} else {//CONTINUE or NEED_WAITING
		sc->timeout = current_time() + 60;
		return;
	}


	if(ti->t->type == TASK_TYPE_DOWNLOAD || ti->t->type == TASK_TYPE_UPLOAD) {
		ti->fault_code = fault_code;
		war_snprintf(ti->complete_time, sizeof(ti->complete_time), "%s", lib_current_time());
#ifdef TR143
	} else if(res == HTTP_COMPLETE && ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS && res_code == 200) {
		sc->timeout = current_time() + 60;
		sc->on_readable = dd_waiting_peer_close;
		sc->on_timeout = dd_waiting_peer_close;
		return;
#endif
	}
	sc->need_destroy = 1;
}

static void task_waiting_start(struct sched *sc)
{
	struct task_item *ti;
	int res = -1;


	ti = (struct task_item *)(sc->pdata);
#ifdef TR143
	if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS || ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS) {
		ti->t->du.diag.eod = "Error_InitConnectionFailed";
		war_gettimeofday(&(ti->t->du.diag.request_time), NULL);
	} else 
#else
#endif
	{
		war_snprintf(ti->start_time, sizeof(ti->start_time), "%s", lib_current_time());
		ti->t->state = TASK_STATE_IN_PROCESS; 
	}

	res = tr_conn(&(ti->conn), ti->t->url);
	if(res < 0) {
		sc->need_destroy = 1;
		if(ti->t->type == TASK_TYPE_DOWNLOAD) {
			ti->fault_code = 9010;
		} else if(ti->t->type == TASK_TYPE_UPLOAD) {
			ti->fault_code = 9011;
		}
	} else {
		int limit;
#ifdef TR143
		if(ti->t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS || ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS) {
			if(war_setsockopt(ti->conn.fd, SOL_SOCKET, SO_PRIORITY, (char *)&(ti->t->du.diag.ep), sizeof(ti->t->du.diag.ep)) < 0) {
				tr_log(LOG_ERROR, "Set ethernet priority failed: %s", war_strerror(war_getsockerror()));
				sc->need_destroy = 1;
				return;
			}
			if(war_setsockopt(ti->conn.fd, SOL_IP, IP_TOS, (char*)&(ti->t->du.diag.dscp), sizeof(ti->t->du.diag.dscp)) < 0) {
				tr_log(LOG_ERROR, "Set ToS failed: %s", war_strerror(war_getsockerror()));
				sc->need_destroy = 1;
				return;
			}
		}
#endif
		limit = ti->http.body_limit;
		http_destroy(&(ti->http));
		ti->http.body_limit = limit;
		sc->type = SCHED_WAITING_WRITABLE;
		sc->timeout = current_time() + 60;
		ti->challenged = 0;
		ti->next_step = TASK_NEXT_HTTP_HEADER;
		sc->fd = ti->conn.fd;
		sc->on_timeout = task_timeout;
		sc->on_writable = on_task_writable;
		sc->on_readable = on_task_readable;
	}
}

#ifdef TR143
static void update_time(const char *path, struct timeval *tv)
{
	node_t node;
	const char *ct;

	ct = echo_current_time(tv);
	if(lib_resolve_node(path, &node) == 0) {
		lib_set_value(node, ct);
	}
}

static void update_unsigned_int(const char *path, unsigned int ui)
{
	node_t node;
	char sui[32];

	war_snprintf(sui, sizeof(sui), "%u", ui);
	if(lib_resolve_node(path, &node) == 0)
		lib_set_value(node, sui);
}
#endif


// 2011.03.25
int task_upgrade_firmware = 0;



static void task_destroy(struct sched *sc)
{
	struct task_item *ti;
	char data[512];
	int need_reboot = 0;

	ti = (struct task_item *)(sc->pdata);
	if(ti->t->type == TASK_TYPE_DOWNLOAD || ti->t->type == TASK_TYPE_UPLOAD) {
		if(ti->t->type == TASK_TYPE_UPLOAD && ti->upfile)
			fclose(ti->upfile);
		if(ti->t->type == TASK_TYPE_DOWNLOAD && ti->http.body && ti->http.body_type == HTTP_BODY_FILE){
			fflush((FILE*)ti->http.body);
		}

		//if(ti->t->type == TASK_TYPE_DOWNLOAD && ti->fault_code != 0)
		//tr_remove(ti->t->target_file_name);

		ti->t->state = TASK_STATE_COMPLETED;
		if(ti->fault_code == 0 && ti->t->type == TASK_TYPE_DOWNLOAD) 
        {
            tr_log(LOG_DEBUG, "ti->http.body=%s, ti->http.body.length=%d\n", (char*)(ti->http.body), ti->http.body_size); //Brian+ for debug
            //need_reboot = lib_download_complete(ti->t->du.file.file_type, ti->t->du.file.target_file_name, ti->http.body_size);
            //need_reboot = lib_download_complete(ti->t->du.file.file_type, ti->t->du.file.target_file_name);
            need_reboot = lib_download_complete(ti->t->du.file.file_type, ti->t->du.file.target_file_name, ti->t->url);

// 2011.03.25
			    if(war_strcasecmp(ti->t->du.file.file_type, "1 Firmware Upgrade Image") == 0)  {
						task_upgrade_firmware = 0;
					}

			if(need_reboot > 1){
				ti->fault_code = need_reboot;
				need_reboot = 0;
			}
			if(need_reboot)
				need_reboot = need_reboot_device();
		}

		if(ti->t->initiated == TASK_INITIATED_ACS){
			war_snprintf(data, sizeof(data),
				"<CommandKey>%s</CommandKey>\n"
				"<FaultStruct>\n"
				"<FaultCode>%d</FaultCode>\n"
				"<FaultString>%s</FaultString>\n"
				"</FaultStruct>\n"
				"<StartTime>%s</StartTime>\n"
				"<CompleteTime>%s</CompleteTime>\n",
				ti->t->du.file.cmd_key,
				ti->fault_code,
				ti->fault_code ? fault_code2string(ti->fault_code) : "",
				ti->fault_code ? UNKNOWN_TIME : ti->start_time,
				ti->fault_code ? UNKNOWN_TIME : ti->complete_time);
		}else{
			war_snprintf(data, sizeof(data),
 				"<AnnounceURL>%s</AnnounceURL>\n"
 				"<TransferURL>%s</TransferURL>\n"
 				"<IsDownload>%s</IsDownload>\n"
				"<FileType>%s</FileType>\n"
				"<FileSize>%d</FileSize>\n"
				"<TargetFileName></TargetFileName>\n"
				"<FaultStruct>\n"
				"<FaultCode>%d</FaultCode>\n"
				"<FaultString>%s</FaultString>\n"
				"</FaultStruct>\n"
				"<StartTime>%s</StartTime>\n"
				"<CompleteTime>%s</CompleteTime>\n",
 				ti->t->announce_url,
 				ti->t->url,
 				ti->t->type == TASK_TYPE_DOWNLOAD ? "true":"false",
				ti->t->du.file.file_type,
				ti->t->du.file.file_size,
				ti->fault_code,
				ti->fault_code ? fault_code2string(ti->fault_code) : "",
				ti->fault_code ? UNKNOWN_TIME : ti->start_time,
				ti->fault_code ? UNKNOWN_TIME : ti->complete_time);
		}

		if(ti->t->initiated == TASK_INITIATED_ACS)
 			add_request("TransferComplete", ti->t->type == TASK_TYPE_DOWNLOAD ? M_EVENT_DOWNLOAD : M_EVENT_UPLOAD, ti->t->du.file.cmd_key, data);
 		else
 			add_request("AutonomousTransferComplete", ti->t->type == TASK_TYPE_DOWNLOAD ? M_EVENT_DOWNLOAD : M_EVENT_UPLOAD, ti->t->du.file.cmd_key, data);

		if(get_event(ti->t->type == TASK_TYPE_DOWNLOAD ? M_EVENT_DOWNLOAD : M_EVENT_UPLOAD, ti->t->du.file.cmd_key) == NULL) {
 			if(ti->t->initiated == TASK_INITIATED_ACS)
 				add_single_event(S_EVENT_TRANSFER_COMPLETE);
 			else
 				add_single_event(S_EVENT_AUTONOMOUS_TRANSFER_COMPLETE);

			add_multi_event(ti->t->type == TASK_TYPE_DOWNLOAD ? M_EVENT_DOWNLOAD : M_EVENT_UPLOAD, ti->t->du.file.cmd_key);
			complete_add_event(need_reboot);
		}
	}
#ifdef TR143
	 else if(ti->t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS) {
		if(ti->t->du.diag.eod) {
			node_t node;
			lib_start_session();
			if(lib_resolve_node(DD_STATE, &node) == 0)
				lib_set_value(node, ti->t->du.diag.eod);
			if(war_strcasecmp(ti->t->du.diag.eod, "Completed") == 0) {
				update_time(DD_ROM, &(ti->t->du.diag.rom));
				update_time(DD_EOM, &(ti->t->du.diag.eom));
				update_time(DD_BOM, &(ti->t->du.diag.bom));
				update_time(DD_TCP_REQUEST_TIME, &(ti->t->du.diag.request_time));
				update_time(DD_TCP_RESPONSE_TIME, &(ti->t->du.diag.response_time));
				update_unsigned_int(DD_TESTBR, ti->http.bytes_received);
				update_unsigned_int(DD_TOTALBR, ti->t->du.diag.total_bytes_received);
			}
			lib_end_session();
			add_single_event(S_EVENT_DIAGNOSTICS_COMPLETE);
			create_session();
		}
	} else {
		if(ti->t->du.diag.eod) {
			node_t node;
			lib_start_session();
			if(lib_resolve_node(UD_STATE, &node) == 0)
				lib_set_value(node, ti->t->du.diag.eod);

			if(war_strcasecmp(ti->t->du.diag.eod, "Completed") == 0) {
				update_time(UD_ROM, &(ti->t->du.diag.rom));
				update_time(UD_EOM, &(ti->t->du.diag.eom));
				update_time(UD_BOM, &(ti->t->du.diag.bom));
				update_time(UD_TCP_REQUEST_TIME, &(ti->t->du.diag.request_time));
				update_time(UD_TCP_RESPONSE_TIME, &(ti->t->du.diag.response_time));
				update_unsigned_int(UD_TBS, ti->t->du.diag.total_bytes_sent);
			}
			lib_end_session();
			add_single_event(S_EVENT_DIAGNOSTICS_COMPLETE);
			create_session();
		}
	}
#endif
	tr_disconn(&(ti->conn));
	http_destroy(&(ti->http));
	destroy_buffer(&(ti->outbuf));
	del_task(ti->t);
	free(ti);
	sc->pdata = NULL;
	if(need_reboot) {
		lib_reboot();
		exit(0);
	}
}

static int launch_task_sched(struct task *t)
{
	struct sched *sched;
	struct task_item *ti;

	ti = calloc(1, sizeof(*ti));
	if(ti == NULL) {
		tr_log(LOG_ERROR, "Out of memory!");
#ifdef TR143
		if(t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS)
			dd_error("Error_InitConnectionFailed");
		else if(t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS)
			ud_error("Error_InitConnectionFailed");

#endif
		return -1;
	} else {
		ti->t = t;

		ti->t->state = TASK_STATE_NOT_STARTED; 

// 2011.03.25
		if(ti->t->type == TASK_TYPE_DOWNLOAD ) 
			if( task_upgrade_firmware ) {
				printf("Stop this firmware\n");
				return 0;
			}


		if(ti->t->type == TASK_TYPE_DOWNLOAD || ti->t->type == TASK_TYPE_UPLOAD) {
			war_snprintf(ti->start_time, sizeof(ti->start_time), UNKNOWN_TIME);
			war_snprintf(ti->complete_time, sizeof(ti->complete_time), UNKNOWN_TIME);
		}

		sched = calloc(1, sizeof(*sched));
		if (sched == NULL) {
			tr_log(LOG_ERROR, "Out of memory!");
			free(ti);
#ifdef TR143
			if(t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS)
				dd_error("Error_InitConnectionFailed");
			else if(t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS)
				ud_error("Error_InitConnectionFailed");
#endif
			return -1;
		} else {
			sched->pdata = ti;
			sched->type = SCHED_WAITING_TIMEOUT;
			sched->on_timeout = task_waiting_start;
			sched->on_destroy = task_destroy;
			ti->t->sc = sched;
			if(ti->t->type == TASK_TYPE_DOWNLOAD || ti->t->type == TASK_TYPE_UPLOAD) {
			    sched->timeout = ti->t->du.file.delay;
			} else {
			    sched->timeout = current_time(); //Upload/Download dignostic , do immediate 
			}
			add_sched(sched);
		}
	}

	return 0;
}


static struct task *next_task(struct task **t)
{
	if(*t == NULL)
		*t = task_list;
	else
		*t = (*t)->next;

	return *t;
}

static int get_task_queue_len()
{
	int count = 0;
	struct task *t;
	for(t = task_list; t; t = t->next) {
		if(t->type == TASK_TYPE_DOWNLOAD || t->type == TASK_TYPE_UPLOAD)
			count++;
	}

	return count;
}


static int __add_task(struct task *new)
{
	new->next = task_list;
	task_list = new;
	return launch_task_sched(new);
}

static int add_task(struct task *t)
{
	int res = -1;

	t->state = TASK_STATE_NOT_STARTED;
#ifdef TR143
	if(t->type == TASK_TYPE_DOWNLOAD_DIAGNOSTICS || t->type == TASK_TYPE_UPLOAD_DIAGNOSTICS) {
		res = __add_task(t);
	} else 
#endif
	if(get_task_queue_len() < TASK_QUEUE_LEN_LIMIT) {
		res = __add_task(t);
		if(res == 0)
			write_task2disk();
	}

	return res;
}

int load_task()
{
	struct task buf;
	struct task *new;
	FILE *fp;
	tr_restore(TASK_FILE);
	fp = tr_fopen(TASK_FILE, "rb");
	if(fp) {
		while(fread(&buf, 1, sizeof(buf), fp) == sizeof(buf)) {
			new = calloc(1, sizeof(buf));
			if(new == NULL) {
				tr_log(LOG_ERROR, "Out of memory!");
				break;
			} else {
				memcpy(new, &buf, sizeof(buf));
				new->sc = NULL;
				if(__add_task(new) != 0)
					free(new);
			}
		}
		fclose(fp);
	}

	return 0;
}

#ifdef TR143
static void stop_udd(int type)
{
	struct task *t;
	for(t = task_list; t; t = t->next) {
		if(t->type == type && t->sc) {
			t->sc->need_destroy = 1;
			t->sc = NULL;
			t->du.diag.eod = NULL;
		}
	}
}

void stop_dd()
{
	tr_log(LOG_DEBUG, "Stop Download diagnostics");
	stop_udd(TASK_TYPE_DOWNLOAD_DIAGNOSTICS);
}
void stop_ud()
{
	tr_log(LOG_DEBUG, "Stop Upload diagnostics");
	stop_udd(TASK_TYPE_UPLOAD_DIAGNOSTICS);
}

static void start_udd(int type)
{
	struct task *t;

	t = calloc(1, sizeof(*t));
	if(t == NULL) {
		tr_log(LOG_ERROR, "Out of memory!");
	} else {
		int res;
		static int first = 1;
		if(first) {
			//Register value change trigger
			first = 0;
		}
		t->type = type;
		if(lib_start_session() > 0) {
			char buf[32] = "0";
			res = 0;
			if(type == TASK_TYPE_UPLOAD_DIAGNOSTICS) {
				GET_NODE_VALUE(UD_INTERFACE, t->du.diag.inter);
				GET_NODE_VALUE(UD_URL, t->url);
				GET_NODE_VALUE(UD_TFL, buf);
				if(res == 0)
					t->du.diag.test_file_length = atoi(buf);
				GET_NODE_VALUE(UD_DSCP, buf);
				if(res == 0) {
					t->du.diag.dscp = atoi(buf);
					if(t->du.diag.dscp > 63 || t->du.diag.dscp < 0)
						t->du.diag.dscp = 0;
				}
				GET_NODE_VALUE(UD_EP, buf);
				if(res == 0) {
					t->du.diag.ep = atoi(buf);
					if(t->du.diag.ep > 7 || t->du.diag.ep < 0)
						t->du.diag.ep = 0;
				}
			} else {
				GET_NODE_VALUE(DD_INTERFACE, t->du.diag.inter);
				GET_NODE_VALUE(DD_URL, t->url);
				GET_NODE_VALUE(DD_DSCP, buf);
				if(res == 0) {
					t->du.diag.dscp = atoi(buf);
					if(t->du.diag.dscp > 63 || t->du.diag.dscp < 0)
						t->du.diag.dscp = 0;
				}
				GET_NODE_VALUE(DD_EP, buf);
				if(res == 0) {
					t->du.diag.ep = atoi(buf);
					if(t->du.diag.ep > 7 || t->du.diag.ep < 0)
						t->du.diag.ep = 0;
				}
			}
			lib_end_session();
		} else {
			res = -1;
		}
		if(res != 0 || add_task(t) != 0)
			free(t);
	}
}


static void udd_common_changed(int type)
{
	struct task *t;
	for(t = task_list; t; t = t->next) {
		if(t->type == type && t->sc) {
			t->sc->need_destroy = 1;
			t->sc = NULL;
			t->du.diag.eod = NULL;
			if(lib_start_session() > 0) {
				node_t node;
				if(lib_resolve_node(type == TASK_TYPE_UPLOAD_DIAGNOSTICS ? UD_STATE : DD_STATE, &node) == 0) {
					tr_log(LOG_WARNING, "Set related parameter when diagnostics in processing");
					lib_set_value(node, "None");
				}
				lib_end_session();
			}
		}
	}
}

static void download_diagnostics_common_changed(const char *new)
{
	udd_common_changed(TASK_TYPE_DOWNLOAD_DIAGNOSTICS);
}


static void upload_diagnostics_common_changed(const char *new)
{
	udd_common_changed(TASK_TYPE_DOWNLOAD_DIAGNOSTICS);
}

void start_ud()
{
	static int first = 1;
	if(first == 1) {
        	register_vct(UD_INTERFACE, upload_diagnostics_common_changed);
        	register_vct(UD_URL, upload_diagnostics_common_changed);
        	register_vct(UD_EP, upload_diagnostics_common_changed);
        	register_vct(UD_DSCP, upload_diagnostics_common_changed);
        	register_vct(UD_TFL, upload_diagnostics_common_changed);
		first = 0;
	}
	tr_log(LOG_DEBUG, "Start Upload diagnostics");
	start_udd(TASK_TYPE_UPLOAD_DIAGNOSTICS);
}

void start_dd()
{
	static int first = 1;
	if(first == 1) {
        	register_vct(DD_INTERFACE, download_diagnostics_common_changed);
        	register_vct(DD_URL, download_diagnostics_common_changed);
        	register_vct(DD_DSCP, download_diagnostics_common_changed);
        	register_vct(DD_EP, download_diagnostics_common_changed);
		first = 0;
	}
	tr_log(LOG_DEBUG, "Start Download diagnostics");
	start_udd(TASK_TYPE_DOWNLOAD_DIAGNOSTICS);
}
#endif /*TR143*/


//GetQueuedTransfers and GetAllQueuedTransfers
int gqt_body(struct session *ss)
{
	struct buffer buf;
	struct task *t;

	init_buffer(&buf);
	t = ss->cpe_pdata;
	if(t == NULL)
		push_buffer(&buf, "<TransferList xsi:type='soap-enc:Array' soap-enc:arrayType='cwmp:QueuedTransferStruct[%d]'>\n", get_task_queue_len());
	while(next_task(&t)) {
		if(t->type == TASK_TYPE_DOWNLOAD || t->type == TASK_TYPE_UPLOAD) {
			push_buffer(&buf,
					"<QueuedTransferStruct>\n"
					"<CommandKey>%s</CommandKey>\n"
					"<State>%d</State>\n"
					"</QueuedTransferStruct>\n",
					t->du.file.cmd_key, t->state);
			break;
		}
	}

	if(t == NULL)
		push_buffer(&buf, "</TransferList>\n");

	push_buffer(&(ss->outbuf), "%x\r\n%s\r\n", buf.data_len, buf.data);

// 2011.04.14
	push_buffer(&(ss->outbuf2_data), "%s", buf.data);


	destroy_buffer(&buf);

	ss->cpe_pdata = t;

	if(ss->cpe_pdata == NULL)
		return METHOD_COMPLETE;
	else
		return METHOD_MORE_DATA;
}

//GetAllQueuedTransfers
int gaqt_body(struct session *ss)
{
	struct buffer buf;
	struct task *t;

	init_buffer(&buf);
	t = ss->cpe_pdata;
	if(t == NULL)
		push_buffer(&buf, "<TransferList xsi:type='soap-enc:Array' soap-enc:arrayType='cwmp:AllQueuedTransferStruct[%d]'>\n", get_task_queue_len());

	while(next_task(&t)) {
		if(t->type == TASK_TYPE_DOWNLOAD || t->type == TASK_TYPE_UPLOAD) {
			push_buffer(&buf,
					"<AllQueuedTransferStruct>\n"
					"<CommandKey>%s</CommandKey>\n"
					"<State>%d</State>\n"
					"<IsDownload>%d</IsDownload>\n"
					"<FileType>%s</FileType>\n"
					"<FileSize>%d</FileSize>\n"
					"<TargetFileName>%s</TargetFileName>\n"
					"</AllQueuedTransferStruct>\n",
					t->du.file.cmd_key,
					t->state,
					t->type,
					t->du.file.file_type,
					t->du.file.file_size,
					t->du.file.target_file_name);
			break;
		}

	}

	if(t == NULL)
		push_buffer(&buf, "</TransferList>\n");

	push_buffer(&(ss->outbuf), "%x\r\n%s\r\n", buf.data_len, buf.data);

// 2011.04.14
	push_buffer(&(ss->outbuf2_data), "%s", buf.data);

	destroy_buffer(&buf);
	ss->cpe_pdata = t;

	if(ss->cpe_pdata == NULL)
		return METHOD_COMPLETE;
	else
		return METHOD_MORE_DATA;
}

//Download and Upload
int download_upload_process(struct session *ss, char **msg)
{
	struct xml tag;
	struct task *task;
	struct task_config *tc = NULL;
	int found_ck = 0;

// 2011.03.25
	int check_firmware;
	
	check_firmware = 0;

	task = calloc(1, sizeof(struct task));
	if(task == NULL) {
		tr_log(LOG_ERROR, "Out of memory!");
		ss->cpe_pdata = (void *)9002;
		return METHOD_FAILED;
	}

	if(war_strcasecmp(ss->cpe->name, "Download") == 0)
		task->type = TASK_TYPE_DOWNLOAD;
	else
		task->type = TASK_TYPE_UPLOAD;
	ss->cpe_pdata = (void *)0;

	while(ss->cpe_pdata == (void *)0 && xml_next_tag(msg, &tag) == XML_OK) {
		if(war_strcasecmp(tag.name, "CommandKey") == 0) {
			if(tag.value)
				war_snprintf(task->du.file.cmd_key, sizeof(task->du.file.cmd_key), "%s", tag.value);
			found_ck = 1;
		} else if(war_strcasecmp(tag.name, "FileType") == 0) {
			tc = NULL;
			war_snprintf(task->du.file.file_type, sizeof(task->du.file.file_type), "%s", tag.value);
			if(tag.value && *(tag.value))
				tc = get_file_type_by_name(task->type, tag.value);
			else
				ss->cpe_pdata = (void *)9003;
				
// 2011.03.25				
extern TR_LIB_API int lib_download_available(const char * type);

printf("[%s][%d]\n",task->du.file.file_type,task->type);
// put error
				if( task->type==TASK_TYPE_DOWNLOAD) {
printf("1\n");					
					if( lib_download_available(task->du.file.file_type) == 0) {
						printf(" Stop download 1\n");
						ss->cpe_pdata = (void *)9010;
					}

			    if(war_strcasecmp(task->du.file.file_type, "1 Firmware Upgrade Image") == 0)  {
						check_firmware = 1;
					}

				}

				
		} else if(war_strcasecmp(tag.name, "URL") == 0) {
			if(tag.value && *(tag.value)) {
				char *question_mark;

				if(war_strncasecmp(tag.value, "http://", 7) != 0 
#ifdef __ENABLE_SSL__
						&& war_strncasecmp(tag.value, "https://", 8) != 0 
#endif
						&& strstr(tag.value, "://") != NULL) {
					ss->cpe_pdata = (void *)9003;
					break;
				}

				war_snprintf(task->url, sizeof(task->url), "%s", tag.value);
				question_mark = strchr(task->url, '?');
				if(question_mark) {
					char *name, *value;
					question_mark++;
					while(http_next_arg(&question_mark, &name, &value, '&') == 0) {
						if(war_strcasecmp(name, "userinfo") == 0) {
							ss->cpe_pdata = (void *)9003;
							break;
						}
					}
					war_snprintf(task->url, sizeof(task->url), "%s", tag.value);
				}
			} else {
				ss->cpe_pdata = (void *)9003;
			}
		} else if(war_strcasecmp(tag.name, "Username") == 0) {
			if(tag.value)
				war_snprintf(task->du.file.username, sizeof(task->du.file.username), "%s", tag.value);
		} else if(war_strcasecmp(tag.name, "Password") == 0) {
			if(tag.value)
				war_snprintf(task->du.file.password, sizeof(task->du.file.password), "%s", tag.value);
		} else if(war_strcasecmp(tag.name, "FileSize") == 0) {
			if(tag.value) {
				task->du.file.file_size = atoi(tag.value);
				if(task->du.file.file_size < 0) {
					ss->cpe_pdata = (void *)9003;
				}
			}
		} else if(war_strcasecmp(tag.name, "TargetFileName") == 0) {
			if(tag.value)
				war_snprintf(task->du.file.target_file_name, sizeof(task->du.file.target_file_name), "%s", tag.value);
		} else if(war_strcasecmp(tag.name, "DelaySeconds") == 0) {
			if(tag.value) {
				task->du.file.delay = atoi(tag.value);
				if(task->du.file.delay < 0) {
					ss->cpe_pdata = (void *)9003;
				} else {
					task->du.file.delay += war_time(NULL);
				}
			}
		} else if(war_strcasecmp(tag.name, "SuccessURL") == 0) {
			tr_log(LOG_NOTICE, "Not support this feature: SuccessURL!");
		} else if(war_strcasecmp(tag.name, "FailureURL") == 0) {
			tr_log(LOG_NOTICE, "Not support this feature: FailureURL!");
		} else if(war_strcasecmp(tag.name, "/Download") == 0 || war_strcasecmp(tag.name, "/Upload") == 0) {
			break;
		}
	} //while()

	if(tc == NULL)
		ss->cpe_pdata = (void *)9003;

	if(found_ck == 0) {
		tr_log(LOG_WARNING, "No command key found in filetransfer");
		ss->cpe_pdata = (void *)9003;
	}
#ifdef TR196
	if(task->type == TASK_TYPE_UPLOAD &&
			!war_strcasecmp(task->du.file.file_type, "X 00256D 3GPP Performance File")){
		if(lib_gen_pm_file(task->du.file.target_file_name))
			ss->cpe_pdata = (void *)9002;
	}
#endif

	if(ss->cpe_pdata == (void *)0) {
		if(trust_target_file_name == 0 || task->du.file.target_file_name[0] == '\0')
			war_snprintf(task->du.file.target_file_name, sizeof(task->du.file.target_file_name), "%s", tc->path);
		if(task->url[0] == '\0' || task->du.file.file_size < 0) {
			ss->cpe_pdata = (void *)9003;
		} else if(task->type == TASK_TYPE_DOWNLOAD && task->du.file.file_size > 0 && lib_disk_free_space(task->du.file.file_type) < task->du.file.file_size) {
			ss->cpe_pdata = (void *)9010;
		} else if(add_task(task) != 0) {
			ss->cpe_pdata = (void *)9004;
		} else {
			task = NULL;
		}
	}

// 2011.03.25
printf("2\n");					
	if(ss->cpe_pdata == (void *)0) {
printf("3\n");					
		if( check_firmware ) {
printf("4\n");					
						
					if( task_upgrade_firmware ) {
						printf(" Stop download 2\n");
						ss->cpe_pdata = (void *)9010;
					}
					task_upgrade_firmware++;
											    	

		}
	}

	if(task)
		free(task);

	return ss->cpe_pdata == (void *)0 ? METHOD_SUCCESSED : METHOD_FAILED;
}

int download_upload_body(struct session *ss)
{
	struct buffer buf;

	init_buffer(&buf);
	if(ss->cpe_pdata == (void *)0) {
		push_buffer(&buf,
				"<Status>1</Status>\n"
				"<StartTime>"UNKNOWN_TIME"</StartTime>\n"
				"<CompleteTime>"UNKNOWN_TIME"</CompleteTime>\n");
	} else {
		push_buffer(&buf,
				"<FaultCode>%d</FaultCode>\n"
				"<FaultString>%s</FaultString>\n", (int)(ss->cpe_pdata), fault_code2string((int)(ss->cpe_pdata)));
	}

	push_buffer(&(ss->outbuf), "%x\r\n%s\r\n", buf.data_len, buf.data);

// 2011.04.14
	push_buffer(&(ss->outbuf2_data), "%s", buf.data);

	destroy_buffer(&buf);

	return METHOD_COMPLETE;
}

#ifdef TR196
int gen_upload_pm_task(const char *path, const char *user, const char *pwd, const char *url)
{
	struct task *t;	
	t = calloc(1, sizeof(struct task));
	t->initiated = TASK_INITIATED_AUTONOMOUS;
	if(t == NULL){
		tr_log(LOG_ERROR, "Out of memory");
		return -1;
	}
	t->type = TASK_TYPE_UPLOAD;
	war_snprintf(t->du.file.file_type, sizeof(t->du.file.file_type), 
			"%s", "X 00256D 3GPP Performance File");
	//tr_full_name(path, t->du.file.target_file_name, sizeof(t->du.file.target_file_name));
	war_snprintf(t->du.file.target_file_name, sizeof(t->du.file.target_file_name), "%s", path);
	war_snprintf(t->du.file.username, sizeof(t->du.file.username),
			"%s", user);
	war_snprintf(t->du.file.password, sizeof(t->du.file.password),
			"%s",pwd);	
	war_snprintf(t->url, sizeof(t->url), "%s", url);
	t->du.file.delay = current_time();
	add_task(t);
	return 0;
}
#endif

int gen_transfer_task(const char* announce_url, char *data)
{
	struct xml tag;
	int status;
	struct task *t;
	struct task_config *tc = NULL;

	status = xml_next_tag(&data, &tag);
	if(status != XML_OK || war_strcasecmp(tag.name, "Transfer")){
		tr_log(LOG_WARNING, "Invalid transfer xml.");
		return -1;
	}
	
	t = calloc(1, sizeof(struct task));
	t->initiated = TASK_INITIATED_AUTONOMOUS;
	war_snprintf(t->announce_url, sizeof(t->announce_url), "%s", announce_url);
	status = xml_next_tag(&data, &tag);
	if(status == XML_OK && war_strcasecmp(tag.name, "Download") == 0){
		t->type = TASK_TYPE_DOWNLOAD;
		while((status = xml_next_tag(&data, &tag)) == XML_OK){
			if(war_strcasecmp(tag.name, "CommandKey") == 0){
				war_snprintf(t->du.file.cmd_key, sizeof(t->du.file.cmd_key),
						"%s", tag.value);
			}else if(war_strcasecmp(tag.name, "FileType") == 0){
				war_snprintf(t->du.file.file_type, sizeof(t->du.file.file_type),
						"%s", tag.value);
			}else if(war_strcasecmp(tag.name, "URL") == 0){
				war_snprintf(t->url, sizeof(t->url), "%s", tag.value);
			}else if(war_strcasecmp(tag.name, "Username") == 0){
				war_snprintf(t->du.file.username, sizeof(t->du.file.username),
						"%s", tag.value);
			}else if(war_strcasecmp(tag.name, "Password") == 0){
				war_snprintf(t->du.file.password, sizeof(t->du.file.password),
						"%s", tag.value);
			}else if(war_strcasecmp(tag.name, "Filesize") == 0){
				sscanf(tag.value, "%d", &(t->du.file.file_size));
			}else if(war_strcasecmp(tag.name, "TargetFileName") == 0){
				war_snprintf(t->du.file.target_file_name, sizeof(t->du.file.target_file_name),
						"%s", tag.value);
			}else if(war_strcasecmp(tag.name, "DelaySeconds") == 0){
				sscanf(tag.value, "%ld", &(t->du.file.delay));
				t->du.file.delay += current_time();
			}else if(war_strcasecmp(tag.name, "SuccessURL") == 0){
			}else if(war_strcasecmp(tag.name, "FailuerURL") == 0){
			}else if(war_strcasecmp(tag.name, "/Download") == 0){
				break;
			}
		}
		if(status != XML_OK){
			free(t);
			return -1;
		}
	}else if(status == XML_OK && war_strcasecmp(tag.name, "Upload") == 0){
		t->type = TASK_TYPE_UPLOAD;
		while((status = xml_next_tag(&data, &tag)) == XML_OK){
			if(war_strcasecmp(tag.name, "CommandKey") == 0){
				war_snprintf(t->du.file.cmd_key, sizeof(t->du.file.cmd_key),
						"%s", tag.value);
			}else if(war_strcasecmp(tag.name, "FileType") == 0){
				war_snprintf(t->du.file.file_type, sizeof(t->du.file.file_type),
						"%s", tag.value);
			}else if(war_strcasecmp(tag.name, "URL") == 0){
				war_snprintf(t->url, sizeof(t->url), "%s", tag.value);
			}else if(war_strcasecmp(tag.name, "Username") == 0){
				war_snprintf(t->du.file.username, sizeof(t->du.file.username),
						"%s", tag.value);
			}else if(war_strcasecmp(tag.name, "Password") == 0){
				war_snprintf(t->du.file.password, sizeof(t->du.file.password),
						"%s", tag.value);
			}else if(war_strcasecmp(tag.name, "DelaySeconds") == 0){
				sscanf(tag.value, "%ld", &(t->du.file.delay));
				t->du.file.delay += current_time();
			}else if(war_strcasecmp(tag.name, "/Upload") == 0){
				break;
			}
		}
		if(status != XML_OK){
			free(t);
			return -1;
		}
	}else{
		tr_log(LOG_WARNING, "Invalid transfer xml.");
		return -1;
	}
	if(t->du.file.delay == 0)
		t->du.file.delay = current_time();
	tc = get_file_type_by_name(t->type, t->du.file.file_type);
	if(tc != NULL && t->du.file.target_file_name[0] == 0)
		war_snprintf(t->du.file.target_file_name, sizeof(t->du.file.target_file_name), "%s", tc->path);
	add_task(t);
	return 0;
}
