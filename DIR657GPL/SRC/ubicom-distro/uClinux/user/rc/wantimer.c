#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>															
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <linux_vct.h>
#include <rc.h>
#include <sutil.h>
#include "shvar.h"
#include <net/if.h>
#include <net/if_arp.h>
#include <fcntl.h>
#include <sys/wait.h>


// tr069
char *read_ipv6addr(const char *if_name,const int scope, char *ipv6addr,const int length);

/*
* 	Date: 2009-2-3
* 	Name: Nick Chou
* 	Reason: Add for opendir(), readdir(), closedir()
*           To check 3G USB Card connection
*/
#ifdef CONFIG_USER_3G_USB_CLIENT
#include <dirent.h>
#endif

//#define RC_DEBUG_WANTIMER
#ifdef RC_DEBUG_WANTIMER
#define DEBUG_MSG(fmt, arg...)       printf("%s [%d]: "fmt, __FILE__, __LINE__, ##arg)
#else
#define DEBUG_MSG(fmt, arg...) 
#endif

/* wan connect time */
#define WAN_CONNECT_FILE    "/var/tmp/wan_connect_time.tmp"
#define WAN_CONNECT_INIT	0
#define WAN_CONNECT			1
#define WAN_DISCONNECT		2
#define MAX_BYTES			4294967290
/* pppoe connect time */
#define PPPoE_CONNECT_FILE  "/var/tmp/pppoe00_connect_time.tmp"
#define PPPoE_CONNECT_INIT 	0
#define PPPoE_CONNECT		1
#define PPPoE_DISCONNECT	2

/* interface */
#define DHCPC               "dhcpc"
#define PPP					"ppp"
#define PPP_PREFIX          "ppp%c"

/* file */
#define PPPoE_PID_FILE      "/var/run/ppp-0%c.pid"
//#define NVRAM_FILE			"/var/etc/nvram.conf"

#define dhcpc_renew()		KILL_APP_ASYNCH("-SIGUSR1 udhcpc")
#define dhcpc_release()		KILL_APP_ASYNCH("-SIGUSR2 udhcpc")

/* global varible */
static char wan_interface[8] = {0};
static char wan_proto[16] = {0};
int timer_count = 0;
int reset_flag = 0;
int idle_timer = 0;
int max_idle_time = 0;
int ppp_type = 0;
static int dial_on_demand = 0;
static int support_manully = 0;
#ifdef CONFIG_USER_3G_USB_CLIENT
static int usb_led_on=0;
#endif //#ifdef CONFIG_USER_3G_USB_CLIENT

#ifdef IPV6_PPPoE
int ipv6_timer_count = 0;
int ipv6_reset_flag = 0;
int ipv6_idle_timer = 0;
int max_ipv6_idle_time = 0;
#endif

#ifdef MPPPOE
int average_count = 0; 
int log_count = 0;
unsigned long tx_lan_bytes_now = 0;
unsigned long tx_wan_bytes_now = 0;
unsigned long tx_wlan_bytes_now = 0;
unsigned long tx_lan_bytes_before = 0;
unsigned int tx_wan_bytes_before = 0;
unsigned int tx_wlan_bytes_before = 0;
unsigned long rx_lan_bytes_now = 0;
unsigned int rx_wan_bytes_now = 0;
unsigned int rx_wlan_bytes_now = 0;
unsigned long rx_lan_bytes_before = 0;
unsigned int rx_wan_bytes_before = 0;
unsigned int rx_wlan_bytes_before = 0;
unsigned long tx_lan_sum = 0;
unsigned int tx_wan_sum = 0;
unsigned int tx_wlan_sum = 0;
unsigned long rx_lan_sum = 0;
unsigned int rx_wan_sum = 0;
unsigned int rx_wlan_sum = 0;
#endif

int wan_timer_force_down = 0;			/* Set to 1 to force wan_statue to be 'down' */
int wan_timer_force_down_end = 0;		/* Set to 1 so that once _force_down is actioned wan_statue is allowed to resume normal operation */

/*	Date: 2010-01-13
*	Name: Jimmy Huang
*	Reason:	Add support for Windows Mobile 5
*	Note:
*			Currently support CHT 9100 with Windows Mobile Phone 5
*				Before activate WM5's Internet Sharing
*				VendorID: 0bb4
*				ProductID:0b05
*				Once activate WM5's Internet Sharing
*				VendorID: 0bb4
*				ProductID:0303
*				We using ProductID:0303 to check if the device is ready
*			Pid, Vid is generated by AR7161/mips-linux-2.6.15/drivers/usb/core/hub.c
*			driver status is generated by AR7161/mips-linux-2.6.15/drivers/usb/net/usbnet.c
*			driver is using rndis_host
*/
#if defined(CONFIG_USER_3G_USB_CLIENT_WM5) || defined(CONFIG_USER_3G_USB_CLIENT_IPHONE)
char cmd[96]={'\0'};
int init_iphone(void) {
	FILE *fp;
	memset(cmd,'\0',sizeof(cmd));
	unlink(IPHONE_INIT_RESULT);
	sprintf(cmd,"[ -n \"`iphone | grep Success`\" ] && echo 1 > %s",IPHONE_INIT_RESULT);
	system(cmd);
	if((fp = fopen(IPHONE_INIT_RESULT,"r"))!=NULL){
		fclose(fp);
		return 1;
	}
	return 0;
}


#define USB3G_PHONE_DHCP_COUNT 3
#define USB3G_PHONE_IPHONE_MAX_RETRY 3
static int usb3g_phone_dhcp_count = 0;
/*
iphone start flow
1. driver init OK 
2. execute iphone application to send ssl ... to enable internet sharing
3. ifconfig eth2 up
4. udhcpc -i eth2

iphone stop flow
1. kill udhcpc
2. ifconfig eth2 0.0.0.0
3. ifconfig eth2 down
4. execute iphone application to send ssl ... to disable internet sharing
*/
void dhcpc_kill_renew(char *interface){
	int i = 0;
	memset(cmd,'\0',sizeof(cmd));
	switch(usb3g_phone_dhcp_count){
		case 0:
			printf(" wantimer dhcpc (%d): 1st to call %s\n",__LINE__,__func__);
			break;
		case 1:
		case 2:
			// give udhcpc more time to retrieve IP
			printf(" wantimer dhcpc (%d): %d times to call %s, ignore\n",__LINE__,usb3g_phone_dhcp_count,__func__);
			usb3g_phone_dhcp_count ++;
			return ;
		case USB3G_PHONE_DHCP_COUNT:
			usb3g_phone_dhcp_count = 0;
			printf(" wantimer dhcpc (%d): 3rd times to call %s, re-execute udhcpc\n",__LINE__,__func__);
			break;
		default:
			// give udhcpc more time to retrive IP
			printf(" wantimer dhcpc (%d): %d times to call %s, ignore\n",__LINE__,usb3g_phone_dhcp_count,__func__);
			usb3g_phone_dhcp_count ++;
			return ;
	}

	system("[ -n \"`ps | grep udhcpc`\" ] && killall udhcpc");
	if(strcmp(interface,"rndis0") == 0){
		printf(" wantimer dhcpc (%d): bring up interface %s\n",__LINE__,interface);
		// if interface rndis0 is not up, bring it up
		system("[ -n \"`ifconfig | grep rndis0`\" ] || ifconfig rndis0 up");
	}else{
		// other mobile phone will bring different interface
		system("[ -n \"`ifconfig | grep eth2`\" ] && ifconfig eth2 0.0.0.0 && ifconfig eth2 down");
		for(i = 0 ; i < USB3G_PHONE_IPHONE_MAX_RETRY ; i++){
			if(init_iphone() == 1){
				printf("\n\n wantimer dhcpc (%d): init iphone Success\n",__LINE__);
				break;
			}
		}
		printf(" wantimer dhcpc (%d): bring up interface %s\n",__LINE__,interface);
		// if interface rndis0 is not up, bring it up
		system("[ -n \"`ifconfig | grep eth2`\" ] || ifconfig eth2 up");
		
	}
	sprintf(cmd,"udhcpc -i %s -s %s &",interface,DHCPC_DNS_SCRIPT);
	printf(" wantimer dhcpc (%d): %s\n",__LINE__,cmd);
	//cmd_tmp += sprintf(cmd_tmp,"-s %s %s ",wan_specify_dns ? DHCPC_NODNS_SCRIPT:DHCPC_DNS_SCRIPT,tmp_netbios);
	_system(cmd);
	usb3g_phone_dhcp_count ++;

}
#endif

#ifdef MPPPOE
void check_log_file_size(void)
{
	FILE *fp;
	int line_count = 0;
	char buf[1024] = {};
	if(log_count > 15)// per min checking log size
	{
		fp = fopen("/var/log/messages","r");
		if(fp)
		{
			while(fgets(buf,1024,fp))
			{
				line_count++;
				if(line_count > 100)
				{
					fclose(fp);
					init_file("/var/log/messages");
					log_count = 0;
					return;
				}
			
			}

			fclose(fp);
			log_count = 0;
		}
	}
}
#endif

/* get the time(sec) from booting */
static unsigned long uptime(void){
	struct sysinfo info;
	sysinfo(&info);
	return info.uptime;
}

/* get the wan port connection time */
static void set_wan_connect_time(int type){
	FILE *fp = NULL;
	char tmp[10] = {};
	unsigned long connection_time  = 0;      // connection_time time stamp      
	//unsigned long total_connection_time  = 0;      // accumulative time     	
	
	/* open read-only file to get wan connect time stamp */
	fp = fopen(WAN_CONNECT_FILE,"r+");
	if(fp == NULL)
		return ;	

	if(type != WAN_CONNECT_INIT){
		memset(tmp,0,sizeof(tmp))	;
		fgets(tmp,sizeof(tmp),fp);		
		connection_time = atol(tmp);		
	}
	fclose(fp);
	
	/* open writable file to set wan connect time stamp */
	fp = fopen(WAN_CONNECT_FILE,"w+");
	if(fp == NULL)                              
		return ;                                 
		
	/* update new time */	
	switch(type){
		case WAN_CONNECT_INIT:			
			fprintf(fp,"%s","0\n");
			fprintf(fp,"%s","0\n");						
			break;			
		case WAN_CONNECT:
			fprintf(fp,"%lu%s",uptime(),"\n");
			break;						
		case WAN_DISCONNECT:			
			fprintf(fp,"%lu%s", connection_time, "\n");
			break;				
	}		
	fclose(fp);   
}

#ifdef MPPPOE
	/* get the pppoe connection time */
static void set_pppoe00_connect_time(int type){
	FILE *fp = NULL;
	char tmp[10] = {};
	unsigned long reset  = 0;	      // reset time stamp    	
	
	/* open read-only file to get pppoe connect time stamp */
	fp = fopen(PPPoE_CONNECT_FILE,"r+");
	if(fp == NULL)
		return ;	
	if(type != PPPoE_CONNECT_INIT){
		memset(tmp,0,sizeof(tmp))	;
		fgets(tmp,sizeof(tmp),fp);		
		reset = atol(tmp);		
	}
	fclose(fp);
	
	/* open writable file to set pppoe connect time stamp */
	fp = fopen(PPPoE_CONNECT_FILE,"w+");
	if(fp == NULL)                              
		return ;                                 
		
	/* update new time */	
	switch(type){
		case PPPoE_CONNECT_INIT:			
			fprintf(fp,"%s","0\n");	
			break;			
		case PPPoE_CONNECT:
			fprintf(fp,"%lu%s",uptime(),"\n");
			break;						
		case PPPoE_DISCONNECT:			
			fprintf(fp,"%lu%s",reset,"\n");
			break;				          
	}	
	fclose(fp);	      
}

/* copy from httpd/httpd_util.c */
static char *read_ipaddr(char *if_name){
	int sockfd = 0;
	struct ifreq ifr;
	struct in_addr in_addr, netmask;
	int valid = 1;
	static char ipaddr[64] = {};

	if ((sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
		return 0;

	strcpy(ifr.ifr_name, if_name);
	if( ioctl(sockfd, SIOCGIFADDR, &ifr) < 0) 
		valid = 0;

	in_addr.s_addr = sin_addr(&ifr.ifr_addr).s_addr;
	sprintf(ipaddr, "%s", inet_ntoa(in_addr));

	if( ioctl(sockfd, SIOCGIFNETMASK, &ifr) < 0) 
		valid = 0;

	netmask.s_addr = sin_addr(&ifr.ifr_netmask).s_addr;
	sprintf(ipaddr, "%s/%s", ipaddr, inet_ntoa(netmask));
	close(sockfd);

	if(valid == 0)
		return NULL;
	else 
		return ipaddr;
}
#endif //#ifdef MPPPOE

#ifdef DLINK_ROUTER_LED_DEFINE
/* WAN port is not connected to an Ethernet cable */
static int internet_led_behavior_1 = 1;

/* WAN port is physically attached to an Ethernet cable,
   BUT with the following conditions (Not connected to the Internet)
   1. Internet type is configured with Connect on Demandoption 
      but user has not trigger the connection.
   2. Internet type is configured with Manualoption 
      but user has not trigger the connection.*/
static int internet_led_behavior_2 = 1;

/* Ethernet cable is attached, router is properly configured 
   BUT the ISP service is down (No DHCP response, no PPPoE response/authentication failed)*/
static int internet_led_behavior_3 = 0;

/* jimmy added 20080912 */
/*
	SIGPIPE: ppp/pppd/main.c
	SIGTTOU: ppp/pppd/chap_ms.c, ppp/pppd/plugins/rp-pppoe/plugin.c
	SIGTTIN: ppp/pppd/plugins/rp-pppoe/plugin.c, rc/wan.c
	used by rc/wantimer.c
*/
static int pppoe_discovery_fail = 0;
/* -------------------- */
#endif

/*	Date: 2010-01-13
*	Name: Jimmy Huang
*	Reason:	Add support for Windows Mobile 5
*	Note:
*			Currently support CHT 9100 with Windows Mobile Phone 5
*				Before activate WM5's Internet Sharing
*				VendorID: 0bb4
*				ProductID:0b05
*				Once activate WM5's Internet Sharing
*				VendorID: 0bb4
*				ProductID:0303
*				We using ProductID:0303 to check if the device is ready
*			Pid, Vid is generated by AR7161/mips-linux-2.6.15/drivers/usb/core/hub.c
*			driver status is generated by AR7161/mips-linux-2.6.15/drivers/usb/net/usbnet.c
*			driver is using rndis_host
*/
#if defined(CONFIG_USER_3G_USB_CLIENT_WM5) || defined(CONFIG_USER_3G_USB_CLIENT_IPHONE)
char usb_pid[6];
char usb_vid[6];

#ifdef CONFIG_USER_3G_USB_CLIENT_WM5
usb_device_table_t usb_device_rndis_table[]={
	//{vendorID, productID, manufactor, model, os, wan_protocol}
	{"0bb4","0303","CHT","CHT9100","WM5","dhcpc"},
	/*
		ProductID = 0b05: rndis initialized OK, but wm5 not activate internet sharing feature
		ProductID = 0303: rndis initialized OK, wm5 has activated internet sharing feature
		We execute udhcpc when ProductID = 0303
	*/
	{"NULL","NULL","NULL","NULL","NULL","NULL"}
};
/*	Date:	2010-02-05
 *	Name:	Cosmo Chang
 *	Reason:	add usb_type=5 for Android Phone RNDIS feature
 */
usb_device_table_t usb_device_android_rndis_table[]={
	//{vendorID, productID, manufactor, model, os, wan_protocol}	
	{"0bb4","0ffe","HTC","MAGIC","WM5","dhcpc"},	/* Android phone */
	/*
		ProductID = 0c01: rndis initialized OK, but wm5 not activate internet sharing feature
		ProductID = 0ffe: rndis initialized OK, wm5 has activated internet sharing feature
		We execute udhcpc when ProductID = 0ffe
	*/
	{"NULL","NULL","NULL","NULL","NULL","NULL"}
};
#endif

#ifdef CONFIG_USER_3G_USB_CLIENT_IPHONE
usb_device_table_t usb_device_iphone_table[]={
	//{vendorID, productID, manufactor, model, os, wan_protocol}
	{"05ac","1294","apple","iphone-3gs","iphone","dhcpc"},
	/*
		Davicom DM9601 USB Ethernet
		ProductID = 1294:
		whether iphone module init iphone device success or not
		ProductID still the same
		We execute udhcpc after iphone application initial iphone device
	*/
	{"NULL","NULL","NULL","NULL","NULL","NULL"}
};
#endif


/*
	check USB 3G phone WAN status
	return 0 => device not connected, wan interface not up (driver not inited)
	return 1 => device connected, wan interface not up (driver not inited)
	return 2 => device connected, wan interface is up (driver is inited)
*/

int mobile_phone_detect(int device_type){
	FILE *fp;
	int attached = 0;
	int driver_inited = 0;
	int ret = 0;
	char buf[6]={'\0'};
	memset(usb_pid,'\0',sizeof(usb_pid));
	memset(usb_vid,'\0',sizeof(usb_vid));
	usb_device_table_t *device_list = NULL;
	//while(attached == 0){
		if( (fp = fopen(USB_DEVICE_ProductID,"r")) !=NULL ){
			fread(usb_pid,sizeof(usb_pid),1,fp);
			//fgets(usb_pid,sizeof(usb_pid),fp);
			fclose(fp);
		}
		if( (fp = fopen(USB_DEVICE_VendorID,"r")) !=NULL ){
			fread(usb_vid,sizeof(usb_vid),1,fp);
			//fgets(usb_vid,sizeof(usb_vid),fp);
			fclose(fp);
		}
		//printf("pid = %s\t vid = %s\n",usb_pid ,usb_vid);
		switch(device_type){
#ifdef CONFIG_USER_3G_USB_CLIENT_WM5
			case 3: //usb type 3 ==> WM5
				device_list = usb_device_rndis_table;
				break;
/*	Date:	2010-02-05
 *	Name:	Cosmo Chang
 *	Reason:	add usb_type=5 for Android Phone RNDIS feature
 */
			case 5:					
				device_list = usb_device_android_rndis_table;
				break;
#endif

#ifdef CONFIG_USER_3G_USB_CLIENT_IPHONE
			case 4: //usb type 3 ==> iphone
				device_list = usb_device_iphone_table;
				break;
#endif
			default: // should not go here
				break;
		}
		if(usb_pid && (strlen(usb_pid) > 0) && usb_vid && (strlen(usb_vid) > 0)){
			for( ; strncmp(device_list->vendorID,"NULL",4) ; device_list++){
				if((strncmp(usb_vid,device_list->vendorID,strlen(device_list->vendorID))==0) && 
					(strncmp(usb_pid,device_list->productID,strlen(device_list->productID))==0))
				{
					printf("USB Device %s (%s) attached !\n",device_list->manufactor,device_list->os);
					attached = 1;
					//break;
				}
			}
		}
	//}

	//while(driver_inited == 0){
		if( (fp = fopen(USB_MOBILE_INIT_READY,"r")) !=NULL ){
			fread(buf,sizeof(buf),1,fp);
			fclose(fp);
		}
		if(buf && (atoi(buf) == 1)){
			driver_inited = 1;
			//break;
		}
	//}

	//if(strncmp(device_list->os,"WM5",3) == 0){
		//mobile_phone_dial_rndis(device_list->wan_protocol);
	//}
	if(attached){
		ret ++;
		if(driver_inited){
			ret ++;
		}
	}
	
	return ret;
};
#endif


struct user_net_device_stats ife_w_stats;
unsigned long w_rx_packets=0;	/* previous total packets received       */
unsigned long w_tx_packets=0;	/* previous total packets transmitted    */
#define _PATH_PROCNET_DEV               "/proc/net/dev"
static const char *const ss_fmt[] = {
	"%n%llu%u%u%u%u%n%n%n%llu%u%u%u%u%u",
	"%llu%llu%u%u%u%u%n%n%llu%llu%u%u%u%u%u",
	"%llu%llu%u%u%u%u%u%u%llu%llu%u%u%u%u%u%u"
};

struct user_net_device_stats {
	unsigned long rx_packets;	/* total packets received       */
	unsigned long tx_packets;	/* total packets transmitted    */
	unsigned long rx_bytes;	/* total bytes received         */
	unsigned long tx_bytes;	/* total bytes transmitted      */
	unsigned long rx_errors;	/* bad packets received         */
	unsigned long tx_errors;	/* packet transmit problems     */
	unsigned long rx_dropped;	/* no space in linux buffers    */
	unsigned long tx_dropped;	/* no space available in linux  */
	unsigned long rx_multicast;	/* multicast packets received   */
	unsigned long rx_compressed;
	unsigned long tx_compressed;
	unsigned long collisions;

	/* detailed rx_errors: */
	unsigned long rx_length_errors;
	unsigned long rx_over_errors;	/* receiver ring buff overflow  */
	unsigned long rx_crc_errors;	/* recved pkt with crc error    */
	unsigned long rx_frame_errors;	/* recv'd frame alignment error */
	unsigned long rx_fifo_errors;	/* recv'r fifo overrun          */
	unsigned long rx_missed_errors;	/* receiver missed packet     */
	/* detailed tx_errors */
	unsigned long tx_aborted_errors;
	unsigned long tx_carrier_errors;
	unsigned long tx_fifo_errors;
	unsigned long tx_heartbeat_errors;
	unsigned long tx_window_errors;
};

//#define isspace(c) ((((c) == ' ') || (((unsigned int)((c) - 9)) <= (13 - 9))))
#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#define isspace(c) (ISBLANK(c) || (c) == '\n' || (c) == '\r' \
		    || (c) == '\f' || (c) == '\v')

static void get_dev_fields(char *bp, struct user_net_device_stats *ife_stats, int procnetdev_vsn)
{
#if 1
	memset(ife_stats, 0, sizeof(struct user_net_device_stats));

	//printf("string(%d):%s\n",procnetdev_vsn,bp);

	sscanf(bp, "%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u",
		   &ife_stats->rx_bytes, /* missing for 0 */
		   &ife_stats->rx_packets,
		   &ife_stats->rx_errors,
		   &ife_stats->rx_dropped,
		   &ife_stats->rx_fifo_errors,
		   &ife_stats->rx_frame_errors,
		   &ife_stats->rx_compressed, /* missing for <= 1 */
		   &ife_stats->rx_multicast, /* missing for <= 1 */
		   &ife_stats->tx_bytes, /* missing for 0 */
		   &ife_stats->tx_packets,
		   &ife_stats->tx_errors,
		   &ife_stats->tx_dropped,
		   &ife_stats->tx_fifo_errors,
		   &ife_stats->collisions,
		   &ife_stats->tx_carrier_errors,
		   &ife_stats->tx_compressed /* missing for <= 1 */
		   );
#else
	sscanf(bp, ss_fmt[procnetdev_vsn],
		   &ife_stats->rx_bytes, /* missing for 0 */
		   &ife_stats->rx_packets,
		   &ife_stats->rx_errors,
		   &ife_stats->rx_dropped,
		   &ife_stats->rx_fifo_errors,
		   &ife_stats->rx_frame_errors,
		   &ife_stats->rx_compressed, /* missing for <= 1 */
		   &ife_stats->rx_multicast, /* missing for <= 1 */
		   &ife_stats->tx_bytes, /* missing for 0 */
		   &ife_stats->tx_packets,
		   &ife_stats->tx_errors,
		   &ife_stats->tx_dropped,
		   &ife_stats->tx_fifo_errors,
		   &ife_stats->collisions,
		   &ife_stats->tx_carrier_errors,
		   &ife_stats->tx_compressed /* missing for <= 1 */
		   );
#endif

	if (procnetdev_vsn <= 1) {
		if (procnetdev_vsn == 0) {
			ife_stats->rx_bytes = 0;
			ife_stats->tx_bytes = 0;
		}
		ife_stats->rx_multicast = 0;
		ife_stats->rx_compressed = 0;
		ife_stats->tx_compressed = 0;
	}
}

static int procnetdev_version(char *buf)
{
	if (strstr(buf, "compressed"))
		return 2;
	if (strstr(buf, "bytes"))
		return 1;
	return 0;
}

static char *get_name(char *name, char *p)
{
	/* Extract <name> from nul-terminated p where p matches
	   <name>: after leading whitespace.
	   If match is not made, set name empty and return unchanged p */
	int namestart = 0, nameend = 0;

	while (isspace(p[namestart]))
		namestart++;
	nameend = namestart;
	while (p[nameend] && p[nameend] != ':' && !isspace(p[nameend]))
		nameend++;
	if (p[nameend] == ':') {
		if ((nameend - namestart) < IFNAMSIZ) {
			memcpy(name, &p[namestart], nameend - namestart);
			name[nameend - namestart] = '\0';
			p = &p[nameend];
		} else {
			/* Interface name too large */
			name[0] = '\0';
		}
	} else {
		/* trailing ':' not found - return empty */
		name[0] = '\0';
	}
	return p + 1;
}

static int if_readlist_proc(char *target, struct user_net_device_stats *ife_stats)
{
	static int proc_read=0;

	FILE *fh;
	char buf[512];
	int err, procnetdev_vsn;

	if (proc_read)
		return 0;
	if (!target)
		proc_read = 1;

	fh = fopen(_PATH_PROCNET_DEV, "r");
	if (!fh) {
		return -1;
	}
	fgets(buf, sizeof buf, fh);	/* eat line */
	fgets(buf, sizeof buf, fh);

	procnetdev_vsn = procnetdev_version(buf);

	err = 0;
	while (fgets(buf, sizeof buf, fh)) {
		char *s, name[128];

		s = get_name(name, buf);
		if (target && !strcmp(target, name))
		{
			get_dev_fields(s, ife_stats, procnetdev_vsn);
			break;
		}
	}
	if (ferror(fh)) {
		perror(_PATH_PROCNET_DEV);
		err = -1;
		proc_read = 0;
	}
	fclose(fh);
	return err;
}

/* 
	check wan eth connection status, reduce from httpd/httpd_util.c
	return 0 => VCT connected, WAN don't have IP
	return 1 => VCT connected, WAN have IP
	retrun 2 => VCT don't connect

	NOTE: When wan_timer_force_down is asserted then we return 2 always - pretending the connection to be down.
	When wan_timer_force_down_end is asserted then wan_timer_force_down is reset and normal operation resumes
*/
static int wan_statue(const char *proto, int *is_connected)
{
	char *ip_addr = NULL;	
	char status[15] = {0};
	int cable_disconnect = 0;
	
	*is_connected = 1;

	/*
	 * Check force down/end flags - these flags allow the effective stopping/starting of wantimer by 'pretending'
	 * that the wan has been disconnected.  Once _force_down has been asserted it will be actioned at least once
	 */
	if (wan_timer_force_down) {
		if (wan_timer_force_down != 2) {
			/*
			 * Actioned at least once
			 */
			wan_timer_force_down = 2;
			return 2;
		}
		if (!wan_timer_force_down_end) {
			return 2;
		}

		/*
		 * End - resume normal operation.
		 */
		wan_timer_force_down = 0;
		wan_timer_force_down_end = 0;
	}

#ifdef CONFIG_USER_3G_USB_CLIENT

#ifdef CONFIG_USER_3G_USB_CLIENT_IPHONE
	if( (strcmp(wan_proto,"usb3g_phone") == 0) && (nvram_match("usb_type", "4") == 0) ){
		cable_disconnect = mobile_phone_detect(4);
		 DEBUG_MSG("mobile_phone_detect %d (%s) \n",cable_disconnect
				,cable_disconnect == 0 ? "Not attached" : 
				(cable_disconnect == 1 ? "Attached, but driver not initialized" : 
				(cable_disconnect == 2 ? "Attached, driver initialized OK" : "Unknow error")));
		switch(cable_disconnect){
			case 0: // device not attached
				return 2;
			case 1: // device attached, driver not OK
				return 0;
			case 2: //device attached, driver OK
				ip_addr = get_ipaddr(wan_interface);
				if( ip_addr != NULL ){
					 DEBUG_MSG("%s ip_addr = %s, wan_state return 1\n",wan_interface,ip_addr);
					return 1;
				}else{
					DEBUG_MSG("%s ip_addr = NULL, wan_state return 0\n",wan_interface);
					return 0;
				}
			default:
				return 0;
		}
	}else
#endif // end CONFIG_USER_3G_USB_CLIENT_IPHONE
	 if(strcmp(wan_proto, "usb3g")==0 && nvram_match("usb_type", "2")==0) {

		DIR *dir;
		DIR *dir_usb;
		struct dirent *ptr;
		struct dirent *ptr_usb;
		int usb_attached=0;	
		
		dir = opendir("/proc/scsi");		
		if(dir!=NULL)
		{		
		while( (ptr = readdir(dir)) != NULL )
		{
			DEBUG_MSG("d_name : %s\n", ptr->d_name);
			if(strcmp(ptr->d_name, "usb-storage")==0)
			{
				dir_usb = opendir("/proc/scsi/usb-storage");
					if(dir_usb!=NULL)
					{
				while( (ptr_usb = readdir(dir_usb)) != NULL )
				{
					DEBUG_MSG("wantimer: wan_statue: usb attached: %s\n", ptr_usb->d_name);
					if(strcmp(ptr_usb->d_name, ".") && strcmp(ptr_usb->d_name, ".."))
						usb_attached=1;
				}
				closedir(dir_usb);
			}
		}
			}
		closedir(dir);		
		}
		
		/* Check USB Port connection */
		if(!usb_attached)
		{
			if(usb_led_on)
		{
				usb_led_on=0;
				system("/sbin/gpio USB_LED off &");
				/*
					When 3G USB Card from connected to disconnect,
					we have to kill pppd and sleep(2) for USB module deregister USB card.
						1. pppd : kill it for remove option.ko and usbserial.ko
						2. option.ko : 3G data card converter now disconnected from ttyUSB0 and ttyUSB1
						3. usbserial.ko : USB Serial deregistering driver Option 3G data card			
					Then we have to remove USB module for next connection.
				*/
				KILL_APP_ASYNCH("-SIGUSR2 pppd");
				sleep(2);
				system("rmmod option");
				system("rmmod usbserial");
			}	
			DEBUG_MSG("wantimer: wan_statue: USB Port disconnect\n");
#ifdef DLINK_ROUTER_LED_DEFINE
			if(internet_led_behavior_1)
			{
				unlink("/var/tmp/internet_led_blink.tmp");
				system("rm -rf /var/run/gpio_wan_green.pid &");				
				_system("/sbin/gpio SWITCH_CONTROL off &");
				_system("/sbin/gpio INTERNET_LED off amber &");
				_system("/sbin/gpio INTERNET_LED off green &");
				internet_led_behavior_1 = 0;
				internet_led_behavior_2 = 1;
			}
#endif		
			return 2;				
		}	
		else
		{
			if(!usb_led_on)
			{
				usb_led_on=1;
				system("/sbin/gpio USB_LED on &");
			}
			DEBUG_MSG("wantimer: wan_statue: USB Port connect\n");	
		}	
	}
	else
	{
#endif //CONFIG_USER_3G_USB_CLIENT
		
	/* Check WAN VCT connection */	
	VCTGetPortConnectState(wan_interface,VCTWANPORT0,status);
		
#ifdef IP8000
        if(internet_led_behavior_1)
	if( strncmp("disconnect", status, 10) == 0)
	{
	        if (if_readlist_proc("eth1", &ife_w_stats) != -1) {
		        //printf("wan(1) tx-%d-%d rx-%d-%d\n",ife_w_stats.tx_packets,w_tx_packets,ife_w_stats.rx_packets,w_rx_packets);
		        if ((ife_w_stats.tx_packets > w_tx_packets) || (ife_w_stats.rx_packets > w_rx_packets)) {
			        memset(status, 0, 15);
			        strcpy(status, "connect");
		        }
		        w_tx_packets = ife_w_stats.tx_packets;
		        w_rx_packets = ife_w_stats.rx_packets;
	        }
        }
#endif

	if( strncmp("disconnect", status, 10) == 0)
	{
		DEBUG_MSG("wantimer: wan_statue: %s VCT disconnect\n", wan_interface);
#ifdef DLINK_ROUTER_LED_DEFINE
                if( strncmp(proto, "dhcpc", 5) && strncmp(proto, "static", 6) )
                {
		        if(internet_led_behavior_1)
		        {
			        unlink("/var/tmp/internet_led_blink.tmp");
			        system("rm -rf /var/run/gpio_wan_green.pid &");			
			        _system("/sbin/gpio SWITCH_CONTROL off &");
			        _system("/sbin/gpio INTERNET_LED off amber &");
			        _system("/sbin/gpio INTERNET_LED off green &");
			        internet_led_behavior_1 = 0;
			        internet_led_behavior_2 = 1;
		        }
		}
#endif
		*is_connected = 0;		
		return 2;					
	}
#ifdef CONFIG_USER_3G_USB_CLIENT
	}
#endif //CONFIG_USER_3G_USB_CLIENT			
	
#ifdef DLINK_ROUTER_LED_DEFINE	
	internet_led_behavior_1 = 1;
#endif	
	
	/* Check WAN IP */	
	/* check PPPOE/PPTP/L2TP */		
	if( strncmp(proto, "dhcpc", 5) && strncmp(proto, "static", 6) )
	{	
		/* validate ip address */
		ip_addr = get_ipaddr("ppp0");
		if( ip_addr != NULL && strncmp(ip_addr, "10.64.64.64", 11) != 0)
		{
			DEBUG_MSG("wantimer: wan_statue: ppp0 ip_addr=%s\n", ip_addr);
			return 1;	  
		}	
		else
		{ 
			DEBUG_MSG("wantimer: wan_statue: ppp0 ip_addr=NULL\n");
			return 0;
		}	
	}
	else /* check wan_proto=dhcpc/static */
	{
	  	ip_addr = get_ipaddr(wan_interface);
	  	if(ip_addr == NULL)
	  	{
			DEBUG_MSG("wantimer: wan_statue: %s ip_addr=NULL\n", wan_interface);
			return 0;
		}	
		else 
		{
			DEBUG_MSG("wantimer: wan_statue: %s, ip_addr=%s\n", wan_interface, ip_addr);
			return 1;
	}
}
}

#ifdef IPv6_SUPPORT
static int ipv6_wan_state(char *ipv6_wan_if)
{
        char ipv6_addr[50] = {0};
        char status[15] = {0};
        int cable_disconnect = 0;
        static  unsigned long vct_disconn_count = 0;
	int scope;
	if ( strcmp(ipv6_wan_if, "ppp6") == 0 || strcmp(ipv6_wan_if, "sit2") == 0 || strcmp(ipv6_wan_if, "ppp0") == 0 )
		scope = SCOPE_LOCAL;
	else
		scope = SCOPE_GLOBAL;
check_cable:
        VCTGetPortConnectState(wan_interface, VCTWANPORT0, status);

        if( strncmp("disconnect", status, 10) == 0)
        {
                if(vct_disconn_count > 0)
                        cable_disconnect = 1;
                else
                {
                        DEBUG_MSG("wantimer: wan_state: test Cable again !!\n");
                        vct_disconn_count++;
                        goto check_cable;
                }
        }
        else
                vct_disconn_count=0;

        /*================== Check WAN have IPv6 or not=====================================*/

        /* validate ipv6 address */
        if( read_ipv6addr(ipv6_wan_if, scope, ipv6_addr, sizeof(ipv6_addr)) != NULL)
        {
                DEBUG_MSG("wantimer: wan_state: %s ipv6_addr=%s\n",ipv6_wan_if, ipv6_addr);
                if(cable_disconnect)
                        return 2;
                else
                        return 1;
        }
        else
        {
                DEBUG_MSG("wantimer: wan_state: %s ipv6_addr=NULL\n", ipv6_wan_if);
                if(cable_disconnect)
                        return 3;
                else
                        return 0;
        }
}
#endif



void get_wan_interface_proto(void)
{
/*
* Name Albert Chen
* Date 2009-07-21
* Detail change get value method to nvram
*/
//	FILE *fp = fopen(NVRAM_FILE, "r");
//	char line[100] = {};
//	char *p_wan_eth = NULL;
//	char *p_wan_proto = NULL;
//	int counter = 0;
	
//	if(fp == NULL)
//		return;
		
	/* search string wan_eth=XXX */	
//	while( fgets(line, sizeof(line), fp ) != NULL)
//	{
		
//		if(counter == 2)
//			break;
			
//		p_wan_eth = strstr(line, "wan_eth");
//		if(p_wan_eth)
//		{
//			p_wan_eth = p_wan_eth + 8;   // 8 is the length of "wan_eth="
//			memset(wan_interface, 0, sizeof(wan_interface));
//			strncpy(wan_interface, p_wan_eth, strlen(p_wan_eth) - 1);
//			counter++;
//		}
		
//		p_wan_proto = strstr(line, "wan_proto");
//		if(p_wan_proto)
//		{
//			p_wan_proto = p_wan_proto + 10;
//			memset(wan_proto, 0, sizeof(wan_proto));
//			strncpy(wan_proto, p_wan_proto, strlen(p_wan_proto) - 1);
//			counter++;
//		}
//	}	
		
//	fclose(fp);
	strcpy(wan_interface, nvram_safe_get("wan_eth"));
	strcpy(wan_proto, nvram_safe_get("wan_proto"));
}

/*
 * wan_timer_signal_force_down()
 *	When signalled this will cause wan_timer to consider the wan to be down whether it is or not.
 *
 * NOTE: It shall remain down until wan_timer_force_down_end is asserted and _force_down has been checked.
 */
static void wan_timer_signal_force_down(int sig)
{
	DEBUG_MSG("Force down signal received\n");
	wan_timer_force_down = 1;
}

/*
 * wan_timer_signal_force_down_end()
 *	When signalled this will cause wan_timer to resume normal operation.
 */
static void wan_timer_signal_force_down_end(int sig)
{
	DEBUG_MSG("Force down END signal received\n");
	wan_timer_force_down_end = 1;
}

void start_idle_timer(int sig)
{
/*
* Name Albert Chen
* Date 2009-07-21
* Detail change get value method to nvram
*/
//	FILE *fp = fopen(NVRAM_FILE, "r");
//	char line[100] = {};
	char *p_pppoe_idle = NULL, *p_pptp_idle = NULL, *p_l2tp_idle = NULL;
#ifdef CONFIG_USER_3G_USB_CLIENT	
	char *p_usb3g_idle = NULL;
#endif
	
//	if(fp == NULL)
//		return;
		
	if(strcmp(wan_proto, "pppoe") == 0)
	{
//		while( fgets(line, sizeof(line), fp ) != NULL)
//		{
//			p_pppoe_idle = strstr(line, "wan_pppoe_max_idle_time_00");
//			if(p_pppoe_idle)
//			{
//				p_pppoe_idle = p_pppoe_idle + 27;
//				max_idle_time = atoi(p_pppoe_idle)*60;
//				break;
//			}
//		}
		p_pppoe_idle = nvram_safe_get("wan_pppoe_max_idle_time_00");
		max_idle_time = atoi(p_pppoe_idle)*60;
		ppp_type = 1;
	}	
	else if(strcmp(wan_proto, "pptp") == 0)
	{
//		while( fgets(line, sizeof(line), fp ) != NULL)
//		{
//			p_pptp_idle = strstr(line, "wan_pptp_max_idle_time");
//			if(p_pptp_idle)
//			{
//				p_pptp_idle = p_pptp_idle + 23;
//				max_idle_time = atoi(p_pptp_idle)*60;
//				break;
//			}	
//		}	
			p_pptp_idle = nvram_safe_get("wan_pptp_max_idle_time");
			max_idle_time = atoi(p_pptp_idle)*60;
		ppp_type = 2;
	}
	else if(strcmp(wan_proto, "l2tp") == 0)
	{
//		while( fgets(line, sizeof(line), fp ) != NULL)
//		{
//			p_l2tp_idle = strstr(line, "wan_l2tp_max_idle_time");
//			if(p_l2tp_idle)
//			{
//				p_l2tp_idle = p_l2tp_idle + 23;
//				max_idle_time = atoi(p_l2tp_idle)*60;
//				break;
//			}	
//		}
			p_l2tp_idle = nvram_safe_get("wan_l2tp_max_idle_time");
			max_idle_time = atoi(p_l2tp_idle)*60;
		ppp_type = 3;
	}
#ifdef CONFIG_USER_3G_USB_CLIENT		
	else if(strcmp(wan_proto, "usb3g") == 0)
	{
//		while( fgets(line, sizeof(line), fp ) != NULL)
//		{
//			p_usb3g_idle = strstr(line, "usb3g_max_idle_time");
//			if(p_usb3g_idle)
//			{
//				p_usb3g_idle = p_usb3g_idle + 20;
//				max_idle_time = atoi(p_usb3g_idle)*60;
//				break;
//			}	
//		}

                p_usb3g_idle = nvram_safe_get("usb3g_max_idle_time");
				max_idle_time = atoi(p_usb3g_idle)*60;
		ppp_type = 4;
	}
#endif	
		
//	fclose(fp);	
    printf("********** Start PPP IDLE Timer: %d**************\n", max_idle_time);
    idle_timer = 1;
	return ;
}

void stop_idle_timer(int sig)
{
	 printf("Stop WAN IDLE Timer\n");
	 idle_timer = 0;
	 reset_flag = 1;
	 return ;
}

void reset_idle_timer(int sig)
{
     DEBUG_MSG("Reset WAN IDLE Timer\n");
     reset_flag = 1;
     return ;
}

#ifdef IPV6_PPPoE

void start_ipv6_idle_timer()
{
        char *p_pppoe_idle = NULL;
	char ipv6_wan_proto[20] = {0};
        char *tmp;

        tmp = nvram_safe_get("ipv6_wan_proto");
        strcpy(ipv6_wan_proto, tmp);
        if(strcmp(ipv6_wan_proto, "ipv6_pppoe") == 0)
        {
                p_pppoe_idle = nvram_safe_get("ipv6_pppoe_idle_time");
                max_ipv6_idle_time = atoi(p_pppoe_idle)*60;
        }

    printf("********** Start IPv6 PPP IDLE Timer: %d**************\n", max_ipv6_idle_time);
    ipv6_idle_timer = 1;
        return ;
}

void stop_ipv6_idle_timer()
{
         printf("Stop IPv6 WAN IDLE Timer\n");
         ipv6_idle_timer = 0;
         ipv6_reset_flag = 1;
         return ;
}

void reset_ipv6_idle_timer()
{
     DEBUG_MSG("Reset IPv6 WAN IDLE Timer\n");
     ipv6_reset_flag = 1;
     return ;
}

#endif

#ifdef MPPPOE
void write_average_bytes(void)
{
	char temp[32] = {};
	strcpy(temp,display_lan_bytes(TXBYTES,LAN_TX_BYTES));

	if(strcmp(temp,"ERROR") != 0)
	{
		if(tx_lan_bytes_before == 0 && tx_lan_bytes_before < MAX_BYTES)//the first time to execute
			tx_lan_bytes_now = tx_lan_bytes_before = atol(temp);	
		else if(tx_lan_bytes_before != 0 && tx_lan_bytes_before < MAX_BYTES)
		{
			tx_lan_bytes_now = atol(temp) - tx_lan_bytes_before;
			tx_lan_bytes_before = atol(temp);
		}
		tx_lan_sum = tx_lan_sum + tx_lan_bytes_now;
	}
	memset(temp,0,32);
	strcpy(temp,display_wan_bytes(TXBYTES,WAN_TX_BYTES));
	
	if(strcmp(temp,"ERROR") != 0)
        {
		if(tx_wan_bytes_before == 0 && tx_wan_bytes_before < MAX_BYTES)//the first time to execute
                	tx_wan_bytes_now = tx_wan_bytes_before = atol(temp);
        	else if(tx_wan_bytes_before != 0 && tx_wan_bytes_before < MAX_BYTES)
        	{
                	tx_wan_bytes_now = atol(temp) - tx_wan_bytes_before;
                	tx_wan_bytes_before = atol(temp);
		}
        	tx_wan_sum = tx_wan_sum + tx_wan_bytes_now;
	}
	memset(temp,0,32);
	strcpy(temp,display_wlan_bytes(TXBYTES,WLAN_TX_BYTES));

	if(strcmp(temp,"ERROR") != 0)
        {
		if(tx_wlan_bytes_before == 0 && tx_wlan_bytes_before < MAX_BYTES)//the first time to execute
                	tx_wlan_bytes_now = tx_wlan_bytes_before = atol(temp);
        	else if(tx_wlan_bytes_before != 0 && tx_wlan_bytes_before < MAX_BYTES)
        	{
                	tx_wlan_bytes_now = atol(temp) - tx_wlan_bytes_before;
                	tx_wlan_bytes_before = atol(temp);
        	}
        	tx_wlan_sum = tx_wlan_sum + tx_wlan_bytes_now;
	}
	memset(temp,0,32);
	strcpy(temp,display_lan_bytes(RXBYTES,LAN_RX_BYTES));
	
	if(strcmp(temp,"ERROR") != 0)
        {
		if(rx_lan_bytes_before == 0 && rx_lan_bytes_before < MAX_BYTES)//the first time to execute
                	rx_lan_bytes_now = rx_lan_bytes_before = atol(temp);
        	else if(rx_lan_bytes_before != 0 && rx_lan_bytes_before < MAX_BYTES)
        	{
                	rx_lan_bytes_now = atol(temp) - rx_lan_bytes_before;
                	rx_lan_bytes_before = atol(temp);
        	}
        	rx_lan_sum = rx_lan_sum + rx_lan_bytes_now;
	}
	memset(temp,0,32);
        strcpy(temp,display_wan_bytes(RXBYTES,WAN_RX_BYTES));
        
	if(strcmp(temp,"ERROR") != 0)
        {
		if(rx_wan_bytes_before == 0 && rx_wan_bytes_before < MAX_BYTES)//the first time to execute
                	rx_wan_bytes_now = rx_wan_bytes_before = atol(temp);
        	else if(rx_wan_bytes_before != 0 && rx_wan_bytes_before < MAX_BYTES)
        	{
                	rx_wan_bytes_now = atol(temp) - rx_wan_bytes_before;
                	rx_wan_bytes_before = atol(temp);
        	}
        	rx_wan_sum = rx_wan_sum + rx_wan_bytes_now;
	}
	memset(temp,0,32);
        strcpy(temp,display_wlan_bytes(RXBYTES,WLAN_RX_BYTES));
	
	if(strcmp(temp,"ERROR") != 0)
        {
		if(rx_wlan_bytes_before == 0 && rx_wlan_bytes_before < MAX_BYTES)//the first time to execute
                	rx_wlan_bytes_now = rx_wlan_bytes_before = atol(temp);
        	else if(rx_wlan_bytes_before != 0 && rx_wlan_bytes_before < MAX_BYTES)
        	{
                	rx_wlan_bytes_now = atol(temp) - rx_wlan_bytes_before;
                	rx_wlan_bytes_before = atol(temp);
        	}
        	rx_wlan_sum = rx_wlan_sum + rx_wlan_bytes_now;
	}

	if(average_count == 6)
	{
		if(tx_lan_sum < MAX_BYTES && tx_lan_bytes_now != 0)
			tx_lan_sum = tx_lan_sum / 10;
		if(tx_wan_sum < MAX_BYTES && tx_wan_bytes_now != 0)
                        tx_wan_sum = tx_wan_sum / 10;
		if(tx_wlan_sum < MAX_BYTES && tx_wlan_bytes_now != 0)
                        tx_wlan_sum = tx_wlan_sum / 10;
		if(rx_lan_sum < MAX_BYTES && rx_lan_bytes_now != 0)
                        rx_lan_sum = rx_lan_sum / 10;
		if(rx_wlan_sum < MAX_BYTES && rx_wan_bytes_now != 0)
                        rx_wan_sum = rx_wan_sum / 10;
		if(rx_wlan_sum < MAX_BYTES && rx_wlan_bytes_now != 0)
                        rx_wlan_sum = rx_wlan_sum / 10;

		if(tx_lan_sum < MAX_BYTES\
		 && tx_wan_sum < MAX_BYTES && tx_wlan_sum < MAX_BYTES \
		&& rx_lan_sum < MAX_BYTES && rx_wlan_sum < MAX_BYTES && rx_wlan_sum < MAX_BYTES)
		{
			init_file(AVERAGE_BYTES);
			if(nvram_match("wlan0_enable","0") == 0)
        		{
				tx_wlan_sum = 0;
				rx_wlan_sum = 0;
			}
			save2file(AVERAGE_BYTES,"%u/%u/%u/%u/%u/%u\n",tx_lan_sum,tx_wan_sum,tx_wlan_sum,rx_lan_sum,rx_wan_sum,rx_wlan_sum);
		}
		average_count = 0;
	}
}
#endif //#ifdef MPPPOE


// tr069 use
// 2011.04.22

#define SCOPE_LOCAL     0
#define SCOPE_GLOBAL    1

#define MAX_IPV6_IP_LEN	45
int get_wan_ipv6(char *ipv6);


int get_lan_ipv6(char *ipv6)
{
    if (read_ipv6addr(nvram_safe_get("lan_bridge"), SCOPE_GLOBAL, ipv6, MAX_IPV6_IP_LEN)==NULL)
    	return 0;
//        strcpy(global_lanip,"(null)"); //avoiding ui get empty string cause show error
    return 1;
}



int get_wan_ipv6(char *ipv6)
{
    char wan_interface[8] = {};
    char *wan_eth = NULL;
    char wan_proto[50];

//	char dhcp_pd_enable[10]={0};
//	char dhcp_pd[100]={0};
	char ppp6_ip[64] = {}; 
	char autoconfig_ip[64] = {}; 

    strcpy(wan_proto, nvram_safe_get("ipv6_wan_proto"));
//strcpy(lan_bridge, nvram_safe_get("lan_bridge"));
    wan_eth = nvram_safe_get("wan_eth");

    if (strcmp(wan_proto, "ipv6_6to4") == 0)
        strcpy(wan_interface, "tun6to4");
    else if (strcmp(wan_proto, "ipv6_6in4") == 0)
        strcpy(wan_interface, "sit1");
    else if (strcmp(wan_proto, "ipv6_pppoe") == 0)
    		if(nvram_match("ipv6_pppoe_share", "1") == 0)
						strcpy(wan_interface, "ppp0");
				else
        strcpy(wan_interface, "ppp6");
        else if(strcmp(wan_proto, "ipv6_6rd") == 0)
        	strcpy(wan_interface, "sit2");
        else if(strcmp(wan_proto, "ipv6_autodetect") == 0) 
		if(read_ipv6addr("ppp0", SCOPE_GLOBAL, ppp6_ip, sizeof(ppp6_ip))){ 
			strcpy(wan_interface, "ppp0"); 
			strcpy(wan_proto, "ipv6_pppoe"); 
		}else if(read_ipv6addr(wan_eth, SCOPE_GLOBAL, autoconfig_ip, sizeof(autoconfig_ip))){ 
			 strcpy(wan_interface, wan_eth); 
			 strcpy(wan_proto, "ipv6_autoconfig"); 
		 }else{ 
			 strcpy(wan_interface, wan_eth); 
			 strcpy(wan_proto, "ipv6_autodetect"); 
		} 
        else{
	strcpy(wan_interface, wan_eth);
	}


    if (read_ipv6addr(wan_interface, SCOPE_GLOBAL, ipv6, 5*MAX_IPV6_IP_LEN+4 )!=NULL)
    	return 1;

	return 0;	
}




#ifdef DLINK_ROUTER_LED_DEFINE
void set_manu_mode(int sig)
{
     DEBUG_MSG("rcv SIGALRM from start_wan()\n");
     support_manully = 1;
     dial_on_demand = 0;
     return 0;
}

void set_ondemand_mode(int sig)
{
     DEBUG_MSG("rcv SIGTSTP from start_wan()\n");
     support_manully = 0;
     dial_on_demand = 1;
     return 0;
}

void ppp_link_fail(int sig)
{
	DEBUG_MSG("rcv SIGPIPE from pppd\n");
    internet_led_behavior_3 = 1;
	return 0;
}

/* jimmy added 20080912 */
/*
	SIGPIPE: ppp/pppd/main.c
	SIGTTOU: ppp/pppd/chap_ms.c, ppp/pppd/plugins/rp-pppoe/plugin.c
	SIGTTIN: ppp/pppd/plugins/rp-pppoe/plugin.c, rc/wan.c
	used by rc/wantimer.c
*/

void pppoe_discovery_info(int sig){
	DEBUG_MSG("rcv SIGTTOU from rp-pppoe\n");
	pppoe_discovery_fail = 1;
}

void pppoe_start(int sig){
	DEBUG_MSG("rcv SIGTTIN from rp-pppoe\n");
	pppoe_discovery_fail = 0;
}
/* -------------------- */
#endif

int wantimer_main(int argc, char** argv)
{
	FILE *fp_wan = NULL;
	FILE *pid_fp = NULL;
	int last_state = 0;
	int connected_wan = 0;
	int connected_ppp = 0;
	int errno;
	int ip_released = 0;
	int vct_disconn = 0;
#ifdef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC
	int start_qos_needed = 0;
	int stop_qos_needed = 0;
#endif
#endif
#ifdef DLINK_ROUTER_LED_DEFINE
	int internet_amber=0;
#endif
  int ppp_is_connected=1;

	/* NickChou add vct_disconn_count at 20090610
		When WAN in heavy traffic or QoS control enviroment, 
		sometimes wantimer can not get WAN VCT State.
		So we must give wantimer twice chance to ensure that WAN Port VCT disconnected.
	*/
	unsigned long vct_disconn_count = 0;

#ifdef MPPPOE	
	init_file(AVERAGE_BYTES);
        save2file(AVERAGE_BYTES,"%d/%d/%d/%d/%d/%d\n",0,0,0,0,0,0);
#endif
	
	get_wan_interface_proto();
	if(wan_interface == NULL || wan_proto == NULL)
	{
		printf("wantimer: get wan info. error\n");
		return 1;
	}
	printf("wantimer: wan_interface=%s,wan_proto=%s\n",wan_interface,wan_proto);	
	/* create a file to record wan connect time stamp */
	fp_wan = fopen(WAN_CONNECT_FILE,"w+");
	if(fp_wan == NULL)
	{                              
		printf("wantimer: open WAN_CONNECT_FILE error\n");
		return 1;		
	}			
	fclose(fp_wan);
	
	if (!(pid_fp = fopen("/var/run/wan_timer.pid", "w"))) 
	{
		perror("/var/run/wan_timer.pid");
		return errno;
	}
	fprintf(pid_fp, "%d\n", getpid());
	fclose(pid_fp);
	
	/* initial wan port connect time stamp */
	set_wan_connect_time(WAN_CONNECT_INIT);
		
	/*
	 * <gareth.williams@ubicom.com>
	 * Handlers to force wantimer to bring down the wan or allow it to go up again.
	 */
	signal(SIGILL, wan_timer_signal_force_down);
	signal(SIGSYS, wan_timer_signal_force_down_end);
		
	signal(SIGUSR1, start_idle_timer);	//called by monitor_main()
	signal(SIGUSR2, reset_idle_timer);	//called by monitor_main()
	signal(SIGINT, stop_idle_timer);	//called by monitor_main()
#ifdef DLINK_ROUTER_LED_DEFINE
	signal(SIGALRM, set_manu_mode);     //called by start_wan()
	signal(SIGTSTP, set_ondemand_mode);	//called by start_wan()
	signal(SIGPIPE, ppp_link_fail);		//called by ppp/multilink.c and auth.c
/* jimmy added 20080912 */
/*
	SIGPIPE: ppp/pppd/main.c
	SIGTTOU: ppp/pppd/chap_ms.c, ppp/pppd/plugins/rp-pppoe/plugin.c
	SIGTTIN: ppp/pppd/plugins/rp-pppoe/plugin.c, rc/wan.c
	used by rc/wantimer.c
*/
	signal(SIGTTOU,pppoe_discovery_info);//called by ppp/pppd/plugins/rp-pppoe/plugin.c
	signal(SIGTTIN,pppoe_start);//called by ppp/pppd/plugins/rp-pppoe/plugin.c
/* -------------------------- */
#endif	
#ifdef IPV6_PPPoE 
	signal(SIGTRAP,start_ipv6_idle_timer);
	signal(SIGABRT,reset_ipv6_idle_timer);
	signal(SIGILL, stop_ipv6_idle_timer);
#endif
	idle_timer = 0;
	vct_disconn = 1;

#ifdef IPv6_SUPPORT
        int last_ipv6_state = 3;
        char ipv6_wan_proto[20] = {0};
        char ipv6_wan_if[20] = {0};
        int ipv6_state;
	char last_ipv4_addr[30] = {0};
	char ipv4_addr[30] = {0};
        char *tmp;
        tmp = nvram_safe_get("ipv6_wan_proto");
        strcpy(ipv6_wan_proto, tmp);
        if (strcmp(ipv6_wan_proto,"ipv6_pppoe")==0 )
		if(nvram_match("ipv6_pppoe_share", "1") == 0)
	                strcpy(ipv6_wan_if, "ppp0");
		else
        	        strcpy(ipv6_wan_if, "ppp6");
        else if (strcmp(ipv6_wan_proto,"ipv6_6in4")==0 )
                strcpy(ipv6_wan_if, "sit1");
        else if (strcmp(ipv6_wan_proto,"ipv6_6to4")==0 )
                strcpy(ipv6_wan_if, "tun6to4");
	else if (strcmp(ipv6_wan_proto, "ipv6_6rd") == 0 )
		strcpy(ipv6_wan_if, "sit2");
        else  // ipv6_static, ipv6_dhcp, ipv6_stateless
                strcpy(ipv6_wan_if, wan_interface);
#endif
	
	sleep(5); //NickChou, give wan chance to get ip, and wait for VCT ready
	
	int is_msg_written = 0;
	while(1)
	{
		char data[2] = {0};
		FILE *fp = fopen(RC_FLAG_FILE,"r"); 
		
		/* Display INTERNET orange LED for MP request */
		static int mp_orange_led = 0;
		if ((mp_orange_led >= 1) && (mp_orange_led <= 2)) {
			if(read_pid(GPIO_WAN_GREEN_PID) > 0)
			{
			    kill(read_pid(GPIO_WAN_GREEN_PID), SIGHUP);                                
			    system("sbin/gpio INTERNET_LED off green &");			
			}
			mp_orange_led++;
			system("/sbin/gpio INTERNET_LED on amber &");			
			sleep(1);
			continue;
		}

	        if(fp) {
			fread(data, 1, sizeof(data), fp);
			fclose(fp);
			if(strncmp(data, "i", 1) != 0) {
			    	if (!is_msg_written) {
					printf("wantimer WAITING rc to be IDLE\n");
					is_msg_written = 1;
				}

				/*
				 * <gareth.williams@ubicom.com>
				 * Sleep 1 second - stops rapid polling of the RC flag file
				 */
				sleep(1);
				continue;
			}
			is_msg_written = 0;
		}
#ifndef MPPPOE
		if( strcmp(wan_proto, "dhcpc") == 0 || strcmp(wan_proto, "static") == 0
#if defined(CONFIG_USER_3G_USB_CLIENT_WM5) || defined(CONFIG_USER_3G_USB_CLIENT_IPHONE)
			|| strcmp(wan_proto,"usb3g_phone") == 0
#endif	
		) 
		{
#if defined(CONFIG_USER_3G_USB_CLIENT_WM5) || defined(CONFIG_USER_3G_USB_CLIENT_IPHONE)
#endif
			int eth_statue = wan_statue(DHCPC,&ppp_is_connected);		
			DEBUG_MSG(" wantimer dhcpc: eth_statue=%d, connected_wan=%d\n", eth_statue, connected_wan);		
			
			if ((eth_statue == 1) && (mp_orange_led == 0)) {
				mp_orange_led = 1;
				continue;
			}

#ifdef DLINK_ROUTER_LED_DEFINE
			if( eth_statue == 1 && connected_wan == 1 && internet_amber == 1)
			{
				internet_amber=0;
/*
        Reason: let wan led blink
        Modiied: John Huang
        Date: 2009.10.13
*/
				system("/sbin/gpio INTERNET_LED off green &");
				system("/sbin/gpio INTERNET_LED off amber &");
				system("/sbin/gpio INTERNET_LED s_blink green &");
			}
			else
#endif
			if ((eth_statue == 1) && (connected_wan == 0))
			{	/* state from disconnect to connect*/ 
				DEBUG_MSG("wantimer: WAN_CONNECT\n");
				ip_released = 0;
				vct_disconn = 0;
				vct_disconn_count = 0;
				connected_wan = 1;
				set_wan_connect_time(WAN_CONNECT);                          
#ifdef DLINK_ROUTER_LED_DEFINE
				internet_led_behavior_3 = 0;
				internet_amber=1;
				unlink("/var/tmp/internet_led_blink.tmp");
				system("rm -rf /var/run/gpio_wan_green.pid");
				system("/sbin/gpio INTERNET_LED off amber");
				system("/sbin/gpio INTERNET_LED on green");
#endif				                     
#ifdef CONFIG_VLAN_ROUTER
				action_flags.firewall=1;
				start_firewall();
				start_ipsec();
#endif
#ifdef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC
/*
				 *	Date: 2010-May-11
 *	Name: Gareth Williams <gareth.williams@ubicom.com>
 *	Reason: Move streamengine stop/start control into wan timer logic
 */
				start_qos_needed = 1;
#endif
#endif
#ifdef CONFIG_USER_WAN_8021X
/*	Date: 2009-05-23
*	Name: Macpaul Lin
*	Reason:	Add support for enable wan 8021X Auth 
*	Note: this should be executed after interface up and before/at the same 
*		time of  dhcp 
*/
				start_wan_supplicant();
#endif

			}
			else if ((connected_wan == 1) && (eth_statue == 0))
			{	/* state from connecting to disconnect*/
			  	printf("wantimer: WAN_DISCONNECT\n");
			/* jimmy marked 20080215 to prevent dhcpc into release mode
				after trying to renew IP but dhcpd server has gone
			*/
				//dhcpc_release();
			/* -------------------------------------------------------*/
				set_wan_connect_time(WAN_DISCONNECT);
				connected_wan = 0;                   
#ifdef DLINK_ROUTER_LED_DEFINE
				internet_led_behavior_3 = 1;
 				unlink("/var/tmp/internet_led_blink.tmp");
 				system("rm -rf /var/run/gpio_wan_green.pid &");					 				
 				system("/sbin/gpio INTERNET_LED off green &");
				system("/sbin/gpio INTERNET_LED on amber &");
				system("/sbin/gpio SWITCH_CONTROL off &");
#endif					                   
#ifndef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC  
				unlink("/var/tmp/bandwidth_result.txt");
#endif
#endif
#ifdef CONFIG_VLAN_ROUTER
				action_flags.firewall=1;
				stop_firewall();
				stop_ipsec();
#endif
#ifdef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC
/*
				 *	Date: 2010-May-11
 *	Name: Gareth Williams <gareth.williams@ubicom.com>
 *	Reason: Move streamengine stop/start control into wan timer logic
 */
				stop_qos_needed = 1;
#endif
#endif
#ifdef CONFIG_USER_WAN_8021X
/*	Date: 2009-05-23
*	Name: Macpaul Lin
*	Reason:	Add support for enable wan 8021X Auth 
*	Note: this should be executed after interface up and before/at the same 
*		time of  dhcp 
*/
				stop_wan_supplicant();
#endif
			}
			else if(eth_statue == 0 && connected_wan ==0)
			{			
				ip_released = 0;
				if(vct_disconn) /*if VCT from disconnect to connect, but wan don't have IP*/
				{
					/*
					dhcpc_renew();
					printf("wantimer: dhcpc_renew\n");
					sleep(2);
					*/
					/* Date: 2008-12-25
 					 * Name: Ken_chiang
					 * Reason: modify for when wan cable is plug-out but can ping wan ip in static mode issue.					   
					*/
#ifdef CONFIG_USER_WAN_8021X
/*	Date: 2009-05-23
*	Name: Macpaul Lin
*	Reason:	Add support for enable wan 8021X Auth 
*	Note: this should be executed after interface up and before/at the same 
*		time of  dhcp 
*/
					start_wan_supplicant();
#endif

					if( strcmp(wan_proto, "dhcpc") == 0 ){
						dhcpc_renew();
						printf("wantimer: dhcpc_renew\n");
						sleep(2);
					}
#if defined(CONFIG_USER_3G_USB_CLIENT_WM5) || defined(CONFIG_USER_3G_USB_CLIENT_IPHONE)
					else if( strcmp(wan_proto,"usb3g_phone") == 0)
					{
						//if(nvram_match("usb3g_phone_reconnect_mode","always_on") == 0){
						//	DEBUG_MSG("wantimer: always on mode\n");
#ifdef CONFIG_USER_3G_USB_CLIENT_WM5
/*	Date:	2010-02-05
 *	Name:	Cosmo Chang
 *	Reason:	add usb_type=5 for Android Phone RNDIS feature
 */
							if(nvram_match("usb_type", "3")==0 || nvram_match("usb_type", "5")==0){
								// usb mobile phone
								dhcpc_kill_renew(wan_interface);
							}
#endif
#ifdef CONFIG_USER_3G_USB_CLIENT_IPHONE
							if(nvram_match("usb_type", "4")==0){
								// usb mobile phone
								dhcpc_kill_renew(wan_interface);
							}
#endif
							//}else{
								// on_demand , manual
							//}
					}
#endif
					else{						
						ifconfig_up( nvram_safe_get("wan_eth"), nvram_safe_get("wan_static_ipaddr"), nvram_safe_get("wan_static_netmask") );
						route_add( nvram_safe_get("wan_eth"), "0.0.0.0", "0.0.0.0", nvram_safe_get("wan_static_gateway"), 0);
						printf("wantimer: static_up\n");
					}		
				}	
#ifdef DLINK_ROUTER_LED_DEFINE				
				if(internet_led_behavior_3)
				{
					unlink("/var/tmp/internet_led_blink.tmp");
					system("rm -rf /var/run/gpio_wan_green.pid &");					
					system("/sbin/gpio INTERNET_LED off green &");
					system("/sbin/gpio INTERNET_LED on amber &");
					system("/sbin/gpio SWITCH_CONTROL off &");
					internet_led_behavior_3 = 0;
				}
#endif					
#ifndef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC  
				unlink("/var/tmp/bandwidth_result.txt");
#endif			
#endif
			}
			else if(eth_statue == 2)
			{
				DEBUG_MSG("wantimer: VCT_DISCONNECT\n");
				
				if(vct_disconn_count>1000)
					vct_disconn_count = 0;
				else	
					vct_disconn_count++;
					
				if(ip_released == 0 && vct_disconn_count > 1) /*if VCT disconnect, we release ip only once*/
				{
				        connected_wan = 0;	
					ip_released = 1;
					vct_disconn = 1;

		                        if(internet_led_behavior_1)
		                        {
			                        unlink("/var/tmp/internet_led_blink.tmp");
			                        system("rm -rf /var/run/gpio_wan_green.pid");			
			                        _system("/sbin/gpio SWITCH_CONTROL off");
			                        _system("/sbin/gpio INTERNET_LED off amber");
			                        _system("/sbin/gpio INTERNET_LED off green");
			                        internet_led_behavior_1 = 0;
			                        internet_led_behavior_2 = 1;
		                        }

					/*
					dhcpc_release();
					printf("wantimer: dhcpc_release (VCT_DISCONNECT)\n");
					*/
					/* Date: 2008-12-25
 					 * Name: Ken_chiang
					 * Reason: Reason: modify for when wan cable is plug-out 
					 	but can ping wan ip in static mode issue.					   					   
					*/
					if( strcmp(wan_proto, "dhcpc") == 0 ){
						dhcpc_release();
						printf("wantimer: dhcpc_release (VCT_DISCONNECT)\n");
					}
					else
					{
						_system("ifconfig %s 0.0.0.0", nvram_safe_get("wan_eth"));
						printf("wantimer: static IP down (VCT_DISCONNECT)\n");
					}		
#ifdef CONFIG_VLAN_ROUTER
					action_flags.firewall=1;
					stop_firewall();
					stop_ipsec();
#endif
#ifdef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC
/*
					 *	Date: 2010-May-11
 *	Name: Gareth Williams <gareth.williams@ubicom.com>
 *	Reason: Move streamengine stop/start control into wan timer logic
 */
					stop_qos_needed = 1;
#endif
#endif
#ifdef CONFIG_USER_WAN_8021X
/*	Date: 2009-05-23
*	Name: Macpaul Lin
*	Reason:	Add support for enable wan 8021X Auth 
*	Note: this should be executed after interface up and before/at the same 
*		time of  dhcp 
*/
					stop_wan_supplicant();
#endif
#ifdef DLINK_ROUTER_LED_DEFINE				
				        internet_led_behavior_3 = 1;
#endif				
#ifndef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC  
				        unlink("/var/tmp/bandwidth_result.txt");
#endif		
#endif
				}
			}			
		}
		else if (strcmp(wan_proto, "dslite") != 0)/* check ppp connection */
		{		
			int ppp_statue = wan_statue(PPP,&ppp_is_connected);
			if(access(WIZARD_IPV6, F_OK) == 0) //Joe Hunag:If IPv6 wizard is working, do not change ppp status.
				ppp_statue = connected_ppp;	
			
			DEBUG_MSG("ppp_statue=%d, connected_ppp=%d\n", ppp_statue, connected_ppp);		
#ifdef DLINK_ROUTER_LED_DEFINE					
			DEBUG_MSG("ppp_link_fail=%d, dial_on_demand=%d, support_manully=%d\n", internet_led_behavior_3, dial_on_demand, support_manully);
#endif			
			if ((ppp_statue == 1) && (connected_ppp == 0))
			{	/* state from disconnect to connect*/					
				printf("wantimer: PPP CONNECT\n");		
				set_wan_connect_time(WAN_CONNECT);  
				connected_ppp = 1;
	            	
#ifdef DLINK_ROUTER_LED_DEFINE
				/* 1. WAN port is physically attached to an Ethernet cable
				   and Device receives WAN IP from DSL or PPP negotiation has successfully complete
				   2. WAN port is receiving traffic: LED flashes in Green in High Speed
				*/
				unlink("/var/tmp/internet_led_blink.tmp");
				system("rm -rf /var/run/gpio_wan_green.pid &");								
				system("/sbin/gpio INTERNET_LED off green &");
				system("/sbin/gpio INTERNET_LED off amber &");
#ifdef	CONFIG_USER_3G_USB_CLIENT	
				/*
					Because WAN Port do not connect with EtherNet Cable,
					So we can usg SWITCH_CONTROL to control LED blinking.
				*/
/*
        Reason: let wan led blink
        Modiied: John Huang
        Date: 2009.10.13
*/
				if(strcmp(wan_proto, "usb3g")==0)		
					system("/sbin/gpio INTERNET_LED s_blink green &");
				else 
					system("/sbin/gpio INTERNET_LED s_blink green &");
#else				
/*
        Reason: let wan led blink
        Modiied: John Huang
        Date: 2009.10.13
*/
				system("/sbin/gpio INTERNET_LED s_blink green &");
#endif	//CONFIG_USER_3G_USB_CLIENT			
				internet_led_behavior_2 = 1;
				internet_led_behavior_3 = 0;
#endif					
#ifdef CONFIG_VLAN_ROUTER
				action_flags.firewall=1;
				start_firewall();
				start_ipsec();
#endif
#ifdef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC
/*
				 *	Date: 2010-May-11
 *	Name: Gareth Williams <gareth.williams@ubicom.com>
 *	Reason: Move streamengine stop/start control into wan timer logic
 */
				start_qos_needed = 1;
#endif
#endif
			}
			else if ((connected_ppp == 1) && (ppp_statue != 1))
			{	/* state from connect to disconnect*/	
			 	printf("wantimer: PPP DISCONNECT-%d\n",ppp_is_connected);
			 	if(idle_timer)
			 		stop_idle_timer(1);
				set_wan_connect_time(WAN_DISCONNECT);
				connected_ppp = 0;			
				if(ppp_is_connected == 0) 
				{
					printf("WAN is disconnected\n");	
					stop_pppoe(0);
				}
#ifdef DLINK_ROUTER_LED_DEFINE
				if(internet_led_behavior_3)
				{
					unlink("/var/tmp/internet_led_blink.tmp");
					system("rm -rf /var/run/gpio_wan_green.pid &");					
					system("/sbin/gpio INTERNET_LED off green &");
					system("/sbin/gpio INTERNET_LED on amber &");
					system("/sbin/gpio SWITCH_CONTROL off &");		
					internet_led_behavior_2 = 1;
					internet_led_behavior_3 = 0;
				}				
				/* Date: 2009-1-23
 				 * Name: Tina_Tsao
				 * Reason: Reason: When WAN interface set to PPTP/L2TP, DUT will not measure WAN speed for QOS.					   					   
				*/
#ifndef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC  
				unlink("/var/tmp/bandwidth_result.txt");
#endif		
#endif
#endif								
#ifdef CONFIG_VLAN_ROUTER
				action_flags.firewall=1;
				stop_firewall();
				stop_ipsec();
#endif
#ifdef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC
/*
				 *	Date: 2010-May-11
 *	Name: Gareth Williams <gareth.williams@ubicom.com>
 *	Reason: Move streamengine stop/start control into wan timer logic
 */
				stop_qos_needed = 1;
#endif
#endif
			}
#ifdef DLINK_ROUTER_LED_DEFINE
			else if( ppp_statue == 0 && connected_ppp == 0 )
			{	/* After Device boot => ppp_statue == 0 && connected_ppp == 0 */	
				if(internet_led_behavior_3)
				{	/*  and ppp dial fail => internet_led_behavior_3 == 1*/
					unlink("/var/tmp/internet_led_blink.tmp");
					system("rm -rf /var/run/gpio_wan_green.pid &");
					system("/sbin/gpio INTERNET_LED off green &");
					system("/sbin/gpio INTERNET_LED on amber &");
					system("/sbin/gpio SWITCH_CONTROL off &");		
					internet_led_behavior_2 = 1;
					internet_led_behavior_3 = 0;
				}
				else
				{
				/* jimmy modified 20080912 */
					//if( internet_led_behavior_2 && (dial_on_demand || support_manully) )
					if( (pppoe_discovery_fail == 0) && internet_led_behavior_2 && (dial_on_demand || support_manully) )
				/* ----------------------------------------- */
					{	/*  but not yet connection => internet_led_behavior_3 == 0
							user has not trigger the connection => internet_led_behavior_2==1 */
						struct stat internet_led_buf;
						if(stat("/var/tmp/internet_led_blink.tmp", &internet_led_buf) != 0)
						{						
							system("/sbin/gpio INTERNET_LED off green &");
							system("/sbin/gpio INTERNET_LED on amber &");
							system("/sbin/gpio SWITCH_CONTROL off &");
						}		
						internet_led_behavior_2 = 0;
					}		
				}	
				/* Date: 2009-1-23
 				 * Name: Tina_Tsao
				 * Reason: Reason: When WAN interface set to PPTP/L2TP, DUT will not measure WAN speed for QOS.					   					   
				*/
#ifndef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC  
				unlink("/var/tmp/bandwidth_result.txt");
#endif		
#endif
			}		
#endif					
		}
#else //ifndef MPPPOE
		/* unknow bug: httpd will die */
    		if(checkServiceAlivebyName("httpd") == 0)
			system("httpd &");
		average_count++;
		write_average_bytes();
		log_count++;
		check_log_file_size();
		//pppd will log at this file,if connect error.
		//This behavior will cause tmp full, if it always dial up fail all the time
		init_file("/var/etc/connect-errors");
#endif //ifndef MPPPOE


// 2011.03.23
#if 1
//	printf("check!!!!\n");
	
	if( strcmp(nvram_safe_get("tr069_enable"),"1")== 0)
	{
		static int tr069_count = 0;
    static int tr069_fail_count=0;
		int ipv4mode;
		int ipv6mode;
		int staticip;
		static int ipv4_run = 0;
		static int ipv6_run = 0;
			
		ipv4mode = 0;
		staticip = 0;
		ipv6mode = 0;

		tr069_count++;


		if( tr069_count > 5) {
	    char global_wanip[5*MAX_IPV6_IP_LEN+4]={0};
	    
			ipv6mode = ipv6_wan_state(ipv6_wan_if);
	        

// 
			
			if( strcmp(nvram_safe_get("wan_proto"), "static") == 0 ) {
				staticip = 1;
				ipv4mode = 1;
			}

			if( ipv4mode  == 0) {
				ipv4mode = wan_ip_is_obtained();
			}

			if( ipv6mode ) {
				ipv6mode = get_wan_ipv6(global_wanip);    				
   			if( ipv6mode) {
  				ipv6mode = get_lan_ipv6(global_wanip);
   			}
   		}


			if ( ipv4mode || ipv6mode ) {
					int kill_tr069;
			
					kill_tr069 = 0;
					
    			if(checkServiceAlivebyName("tr069") == 0)				
						tr069_fail_count++;
					else
						tr069_fail_count=0;
						
				  int ipv6_exist;    
				    
				  ipv6_exist = ipv6mode;
						

//printf("debug->1 %d %d\n",ipv4mode,ipv6_exist);
//printf("debug->2 %d %d\n",ipv4_run,ipv6_run);
					if( ipv4mode || ipv6_exist ) {				
						int call_tr069;
						call_tr069 = 1;
						if( tr069_fail_count > 5) {

							call_tr069 = 1;
							
						}
						else if( ipv4_run == 1 && (ipv6_run == 0 )&& ipv6_exist ) {
							printf("ipv4 exist, but found ipv6 has ip\n");			
							kill_tr069 =1;		
							call_tr069 =1;
						} 
						else if( ipv6_run == 1 && (ipv4_run == 1 )&& ipv4mode == 0 ) {
							printf("ipv6 exist, but found ipv4 has ip\n");					
							kill_tr069 =1;
							call_tr069 =1;
						} 
					
//printf("debug->3 %d %d\n",kill_tr069,call_tr069);

						if( kill_tr069 ) {					
	    				if(checkServiceAlivebyName("tr069")) {				
								KILL_APP_SYNCH("tr069");
	    					printf(" stop tr069\n");
							}
						}
					
						if( call_tr069 ) {
		    			if(checkServiceAlivebyName("tr069") == 0)	{
								ipv4_run = ipv4mode;
								ipv6_run = ipv6_exist; 
								system("tr069 -d /home/tr/conf &");
								tr069_fail_count = 0;
	    					printf(" start tr069\n");
							}
						}

				}
				
			}
			else {
				// should stop tr069
    			if(checkServiceAlivebyName("tr069"))				
	                KILL_APP_SYNCH("tr069");
                tr069_fail_count = 0;
			}
			
		}	
	}
	
#endif



#ifdef IPv6_SUPPORT
                if (strcmp(ipv6_wan_proto,"link_local")==0)
                        goto dont_check_ipv6;
		DEBUG_MSG("ipv6_wan_if = %s\n",ipv6_wan_if);
                ipv6_state = ipv6_wan_state(ipv6_wan_if);
                switch(ipv6_state)
                {
                        case 0:  //Cable Connect, No IP
                                if (last_ipv6_state != 0) {
#if defined(DHCPv6) || defined(IPV6_STATELESS_WAN)
                                        if(strcmp(ipv6_wan_proto,"ipv6_autoconfig") == 0 )
                                        {
                                                char wan_lla[45]={};
						if (access(RDNSSD_PID, F_OK) != 0){
							_system("cli ipv6 rdnssd start %s", ipv6_wan_if);
						}else{
	                                                read_ipv6addr(ipv6_wan_if, SCOPE_LOCAL, wan_lla, sizeof(wan_lla));
        	                                        _system("ip -6 addr del %s dev %s", wan_lla, ipv6_wan_if);
                	                                _system("ip -6 addr add %s dev %s", wan_lla, ipv6_wan_if);
						}
                	                	last_ipv6_state = 0;
						break;
						}

                                        if(strcmp(ipv6_wan_proto,"ipv6_autodetect") == 0 )
                                        {
	                                                char wan_lla[45]={};
							if (access(RDNSSD_PID, F_OK) != 0){
								_system("cli ipv6 rdnssd start %s", ipv6_wan_if);
							}else{
	                                                read_ipv6addr(ipv6_wan_if, SCOPE_LOCAL, wan_lla, sizeof(wan_lla));
        	                                        _system("ip -6 addr del %s dev %s", wan_lla, ipv6_wan_if);
                	                                _system("ip -6 addr add %s dev %s", wan_lla, ipv6_wan_if);
						}
                	                	last_ipv6_state = 0;
						break;
                                        }
#endif

#ifdef IPv6_STATIC
                                        if(strcmp(ipv6_wan_proto,"ipv6_static") == 0 && strlen(nvram_safe_get("ipv6_static_wan_ip")) != 0)
                                        {
						if(nvram_match("ipv6_use_link_local", "0") == 0)
	                                                _system("ip -6 addr add %s/%s dev %s", 
								nvram_safe_get("ipv6_static_wan_ip"),
								nvram_safe_get("ipv6_static_prefix_length"), 
								ipv6_wan_if);
                                                _system("route -A inet6 add default gw %s dev %s", 
							nvram_safe_get("ipv6_static_default_gw"), 
							ipv6_wan_if);
                	                	last_ipv6_state = 0;
						break;
                                        } 
#endif
#ifdef IPV6_TUNNEL
                                        else if (strcmp(ipv6_wan_proto,"ipv6_pppoe") == 0 ) // ipv6_6in4, ipv6_6to4 start_tunnel after have ipv4 address
					{
                	                	last_ipv6_state = 0;
						break;
                                        }
#endif
				// Jery added for setup ipv6_6in4, ipv6_6to4 tunnel, ipv6_6rd_tunnel after get ipv4 address
					if (connected_wan == 1 || 
						((strcmp(wan_proto, "pppoe") == 0 ||
						 strcmp(wan_proto, "pptp") == 0 ||
						 strcmp(wan_proto, "l2tp") == 0 ) && 
						connected_ppp == 1)){

                                                if(nvram_match("wan_proto","pppoe") == 0 ||
                                                        nvram_match("wan_proto","pptp") == 0 ||
                                                        nvram_match("wan_proto","l2tp") == 0 )
                                                        strcpy(ipv4_addr, get_ipaddr("ppp0"));
                                                else
                                                        strcpy(ipv4_addr,  get_ipaddr(nvram_safe_get("wan_eth")));

						if(strcmp(ipv4_addr, last_ipv4_addr) != 0 || strcmp(ipv4_addr,"0.0.0.0") == 0)
							break;

						if (strcmp(ipv6_wan_proto,"ipv6_6in4") == 0){
							system("cli ipv6 6in4 start");
							if (nvram_match("ipv6_dhcp_pd_enable","1") == 0)
								system("cli ipv6 dhcp6c start sit1 oset");
							else{
								system("cli ipv6 dhcp6d stop");
								system("cli ipv6 dhcp6d start");
								system("cli ipv6 radvd stop");
								system("cli ipv6 radvd start");
							}
						}
						if (strcmp(ipv6_wan_proto,"ipv6_6to4") == 0){
							system("cli ipv6 6to4 start");
							system("cli ipv6 dhcp6d stop");
							system("cli ipv6 dhcp6d start");
							system("cli ipv6 radvd stop");
							system("cli ipv6 radvd start");

						}

						if (strcmp(ipv6_wan_proto,"ipv6_6rd") == 0 && nvram_match("ipv6_6rd_dhcp", "0") == 0){
							system("cli ipv6 6rd start");
							system("cli ipv6 dhcp6d stop");
							system("cli ipv6 dhcp6d start");
							system("cli ipv6 radvd stop");
							system("cli ipv6 radvd start");
						}

                	                	last_ipv6_state = 0;
					}
				}
                                break;
                        case 1:  //Cable Connect, Have IP
				DEBUG_MSG("wantimer ipv6: last state=%d, now state=%d\n", last_ipv6_state, ipv6_state);
				if(last_ipv6_state != 1){
					if(nvram_match("wan_proto","pppoe") == 0 ||
						nvram_match("wan_proto","pptp") == 0 ||
						nvram_match("wan_proto","l2tp") == 0 ){
						if (connected_ppp == 1){
							strcpy(last_ipv4_addr, get_ipaddr("ppp0"));
                                			last_ipv6_state = 1;
						}
					}else{
						if(connected_wan == 1){
							strcpy(last_ipv4_addr, get_ipaddr(nvram_safe_get("wan_eth")));
        	                        		last_ipv6_state = 1;
						}
					}

					if (nvram_match("wan_proto", "dslite") == 0){
						if(nvram_match("wan_dslite_dhcp","0") == 0)
							_system("cli ipv6 dslite start");
#ifdef DLINK_ROUTER_LED_DEFINE
						/* Ethernet cable is attached, BUT the ISP service is down 
						(No DHCP response, no PPPoE response/authentication failed)*/
						system("/sbin/gpio INTERNET_LED off green &");
						system("/sbin/gpio INTERNET_LED on amber &");
						system("/sbin/gpio SWITCH_CONTROL off &");
#endif							
						if(access(DSLITE_PID, F_OK) == 0){
							set_wan_connect_time(WAN_CONNECT);
        	                        		last_ipv6_state = 1;
						}
					}
				}
                                break;
                        case 2:  //Cable Disconnect, Have IP
				if (last_ipv6_state != 2)
				{
					DEBUG_MSG("wantimer ipv6: last state=%d, now state=%d\n", last_ipv6_state, ipv6_state);
        	                        _system("ip -6 addr flush scope global dev %s", ipv6_wan_if);
                	                _system("ip -6 route flush root 2000::/3 dev %s", ipv6_wan_if);
#if defined(DHCPv6) || defined(IPV6_STATELESS_WAN)
					if ( strcmp(ipv6_wan_proto,"ipv6_autoconfig") == 0){
					        system("cli ipv6 autoconfig stop");
						system("cli ipv6 rdnssd stop");
					}

					if ( strcmp(ipv6_wan_proto,"ipv6_autodetect") == 0){
						if(nvram_match("wan_proto", "pppoe") == 0)
							system("cli ipv6 pppoe stop");
						else{
					        	system("cli ipv6 autoconfig stop");
							system("cli ipv6 rdnssd stop");
						}
					}
#endif
#ifdef IPV6_PPPoE
					if (strcmp(ipv6_wan_proto,"ipv6_pppoe") == 0)
					        system("cli ipv6 pppoe disdial");
#endif
#ifdef IPV6_TUNNEL
					if (strcmp(ipv6_wan_proto,"ipv6_6in4") == 0)
					{
					        system("cli ipv6 6in4 stop");
					        if ( nvram_match("ipv6_dhcp_pd_enable", "1") == 0){
				        	        system("cli ipv6 dhcp6c stop");
							_system("ip -6 addr flush scope global dev %s",nvram_safe_get("lan_bridge"));
						}
					}

					if (strcmp(ipv6_wan_proto,"ipv6_6to4") == 0)
						system("cli ipv6 6to4 stop");

					if (strcmp(ipv6_wan_proto,"ipv6_6rd") == 0)
						system("cli ipv6 6rd stop");

					if (nvram_match("wan_proto", "dslite") == 0){
						system("cli ipv6 dslite stop");
						set_wan_connect_time(WAN_DISCONNECT);
					}
#endif
					//Joe Huang : In case 2, should stop the idle time countdown.
					if(ipv6_idle_timer)
                	                	stop_ipv6_idle_timer();

						if (WEXITSTATUS(system("killall -0 dhcp6c")) == 0){
						system("killall -9 dhcp6c");
						unlink(DHCP6C_PID);
				}
				}

                	                last_ipv6_state = 2;
                                break;
                        case 3:  //Cable Disconnect, No IP
				if (last_ipv6_state!=3) {
#ifdef defined(DHCPv6) || defined(IPV6_STATELESS_WAN)
                                        if ( strcmp(ipv6_wan_proto,"ipv6_autoconfig") == 0){
                                                system("cli ipv6 autoconfig stop");
						system("cli ipv6 rdnssd stop");
                                        }

					if ( strcmp(ipv6_wan_proto,"ipv6_autodetect") == 0){
						if(nvram_match("wan_proto", "pppoe") == 0)
							system("cli ipv6 pppoe stop");
						else{
					        	system("cli ipv6 autoconfig stop");
							system("cli ipv6 rdnssd stop");
						}
					}
#endif
#ifdef IPV6_TUNNEL
	                                if (strcmp(ipv6_wan_proto,"ipv6_pppoe") == 0)
        	                                system("cli ipv6 pppoe disdial");
	
        	                        if (strcmp(ipv6_wan_proto,"ipv6_6in4") == 0)
					{
                	                        system("cli ipv6 6in4 stop");
						if ( nvram_match("ipv6_dhcp_pd_enable", "1") == 0){
							system("cli ipv6 dhcp6c stop");
							_system("ip -6 addr flush scope global dev %s",nvram_safe_get("lan_bridge"));
						}
					}

                        	        if (strcmp(ipv6_wan_proto,"ipv6_6to4") == 0)
                                	        system("cli ipv6 6to4 stop");

	                                if (strcmp(ipv6_wan_proto,"ipv6_6rd") == 0)
        	                                system("cli ipv6 6rd stop");

					if (nvram_match("wan_proto", "dslite") == 0){
						system("cli ipv6 dslite stop");
						set_wan_connect_time(WAN_DISCONNECT);
					}
#endif
					if (WEXITSTATUS(system("killall -0 dhcp6c")) == 0){
						system("killall -9 dhcp6c");
						unlink(DHCP6C_PID);
					}
				}
				DEBUG_MSG("wantimer ipv6: last state=%d, now state=%d\n", last_ipv6_state, ipv6_state);
                                last_ipv6_state = 3;
                                break;
                }

dont_check_ipv6:
#endif
	
		if(idle_timer)
		{
			if(!(timer_count%10))
				printf("idle timer count %d\n", timer_count);
			
			if(reset_flag)
			{
				timer_count = 0;
				reset_flag = 0;
			}
	
		        timer_count = timer_count + 2; //NickChou, because wantimer sleep(2);
	        
			if(max_idle_time != 0)
		        {
				if(timer_count > (max_idle_time))
				{
				    	printf("PPP Idle Time Out !!!\n");
				    	timer_count = 0;
#ifdef DLINK_ROUTER_LED_DEFINE
					/* the light will flash in Orange in Low Speed 
					if an ADSL connection is still present. */
					{
						system("/sbin/gpio INTERNET_LED s_blink amber &");
						struct stat internet_led_buf;
						if(stat("/var/tmp/internet_led_blink.tmp", &internet_led_buf) != 0)
						{						
							system("/sbin/gpio INTERNET_LED off green &");
							system("/sbin/gpio SWITCH_CONTROL off &");
						}		
					}	
#endif	            			
				    	switch(ppp_type)
				    	{
						case 1:
							stop_pppoe(0);
							idle_timer = 0;
							break;
						case 2:
							stop_pptp();
							idle_timer = 0;
							break;
						case 3:
							stop_l2tp();
							idle_timer = 0;
							break;
#ifdef CONFIG_USER_3G_USB_CLIENT
						case 4:	
							/* 
						 	Date: 2009-2-05 
						 	Name: Nick Chou
						 	Reason: We only remove option.ko and usbserial.ko in two condition
						 				1. 3G USB Card disconnect from USB port.
						 				2. Change WAN type form USB3g to other
						 			So we only kill pppd here to prevent "Connect script failed" error.
							*/ 	
							KILL_APP_ASYNCH("pppd");//stop_usb3g();
							idle_timer = 0;
							break;
#endif
					}	
				}
			}
			else
				idle_timer = 0;
		}

#ifdef CONFIG_USER_STREAMENGINE
#ifdef CONFIG_USER_TC
		/*
		 * If QoS is to be stopped then stop it
		 */
		if (stop_qos_needed) {
			DEBUG_MSG("QoS STOP needed..\n");
			stop_qos();
			stop_qos_needed = 0;
			start_qos_needed = 0;
		}

		/*
		 * If QoS is to be started then try to start it - doesn't always start so we keep trying if it failed to start.
		 */
		if (start_qos_needed) {
			DEBUG_MSG("QoS START needed..\n");
			action_flags.qos = 1;
			start_qos_needed = start_qos();
		}
#endif
#endif

#ifdef IPV6_PPPoE
		if (ipv6_idle_timer)
		{
                        if(!(ipv6_timer_count%10))
                                printf("IPv6 idle timer count %d\n", ipv6_timer_count);

                        if(ipv6_reset_flag)
                        {
                                ipv6_timer_count = 0;
                                ipv6_reset_flag = 0;
                        }

                        ipv6_timer_count = ipv6_timer_count + 2; //NickChou, because wantimer sleep(2);

                        if(max_ipv6_idle_time != 0)
                        {
                                if(ipv6_timer_count > (max_ipv6_idle_time))
                                {
                                        printf("IPv6 PPP Idle Time Out !!!\n");
                                        ipv6_timer_count = 0;
					system("cli ipv6 pppoe disdial");
                                        ipv6_idle_timer = 0;
                                }
                        }
                        else
                                ipv6_idle_timer = 0;
		}		
#endif

		/*
		 * Delay before next wan timer poll
		 */				
		sleep(2);
	}
	return 0;
}

/* 
 * Robert Date : 20100128
 * If wan status is on demand, it will send signal to wantimer.
 * To notify it re-set idle time.
 */
int check_wantimer()
{
        DEBUG_MSG("Check if or not on_demand\n");
        char *proto, key[128];

        proto = nvram_safe_get("wan_proto");
        if ((!strcmp(proto, "dhcpc")) || (!strcmp(proto, "static")))
                return -1;

        if (!strcmp(proto, "pppoe"))
                sprintf(key, "wan_%s_connect_time_00", proto);
        else
                sprintf(key, "wan_%s_connect_time", proto);

        if (!strcmp(nvram_safe_get(key), "on_demand"))
                _system("killall -SIGUSR1 wantimer");
        return 0;
}

